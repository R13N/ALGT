# Example of inference rule parsing

# Types always start with a uppercase letter
# Variables with a lowercase
# expressions as defined in StlcParser

# A file starts with 'Contextsymbol is ' followed by some non-whitespace chars, as no obvious context symbol came to mind
# |- represents 'entails'
# 0.. represent all natural numbers

Contextsymbol is $


 Syntax
========

typeL	::= "Int" | "Bool"
type	::= typeL "->" type | typeL

var	::= identifier
t	::=  tL "+" t | tL "::" type | tL t | tL
tL	::= 0.. | "True" | "False" | var | "(" "\\" var ":" type "." t ")" | "If" t "Then" t "Else" t


 Functions
===========


# reduces one step of the logic
eval: t -> t
eval("If" "True" "Then" t1 "Else" t2) = t1
eval("If" "False" "Then" t1 "Else" t2) = t2
eval("If" cond "Then" t1 "Else" t2) = "If" eval(cond) "Then" t1 "Else" t2
eval("(" "\\" var ":" type "." t ")" arg)
	= subs (var, arg, t)
eval(n1 "+" n2)
	= !plus(eval(n1), eval(n2))
# eval(t "::" type)
#	= t
eval(t)	= t



dom : T -> T
dom(t1 "->" t2) = t1
# undefined otherwises

cod : T -> T
cod(t1 "->" t2) = t2
# undefined otherwise

# Currying syntax as in haskell
equate: T -> T -> T
equate(t1, t1) = t1
# undefined otherwise





# replaces variable x by y in entire t
subs: var -> t -> t -> t
subs(x, y, x)	= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )	= !error("Conflicting environments")
subs(x, y, "(" "\\" z ":" t "." rest ")" )
	= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "if" cond "then" e1 "else" e2)
	= "if" subs(x, y, cond) "then" subs(x, y, e1) "else" subs(x, y, e2)
subs(x, y, t1 "+" t2)
	= subs(x, y, t1) "+" subs(x, y, t2)
# subs(x, y, t "::" type)
#	= subs(x, y, t) "::" type
# subs(x, y, f arg)
#	= subs(x, y, f) subs(x, y, arg)
subs(x, y, z)	= z

# while the parser is sucky, we need helper functions
helperIf : t -> t -> t -> t
helperIf(cond, t1, t2) = "if" eval(cond) "then" t1 "else" t2





 Rules
=======


	x: T in $
(Tx)   ----------- 
	$ |- x: T

(Tn)   ----------------
	$ |- 0.. : Nat


(TbT)   ------------------
	$ |- "True" : Bool


	
(TbF)  ------------------
	$ |- "False": Bool



	$ |- t1 : T1	$ |- t2: T2	T2 == dom(T1)
(Tapp) -----------------------------------------------
	$ |- "(" t1 t2 ")" : cod(T1)


	 $ |- t1 : T1 	$ |- t2 : T2	T1 == "Int"	T2 == "Int"
(Tplus) ------------------------------------------------------------
	 $ |- t1 "+" t2 : "Int"


 	$ |- t1 : T1 	$ |- t2 : T2	$ |- t3: T3	T1 == "Bool"
(Tif) ---------------------------------------------------------------
	$ |- "if" t1 "then" t2 "else" t3 : equate(t2, t3)


	   $, x : T1 |- t : T2
(TLambda) -----------------------------------------------------------
	   $ |- "(" "\\" x ":" T1 "." t ")" : T1 "->" T2



	 $ |- t : T	T = T1
(Tcast)	----------------------------------
	 $ |- (t "::" T1) : T1

