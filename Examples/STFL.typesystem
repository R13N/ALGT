# A simply typed functional language

 Syntax
========

# Types
typeL	::= "Int" | "Bool"
type	::= typeL "->" type | typeL


# builtins values
var	::= Identifier
number	::= Number
bool	::= "True" | "False"
t	::=  tL "+" t | tL "::" type | tL t | tL
tL	::= number | bool | var | "(" "\\" var ":" type "." t ")" | "If" t "Then" t "Else" t | "(" t ")"


typing		::= var "::" type
typingContext	::= typing "," typingContext | ";"


 Functions
===========


# reduces one step of the logic
eval						: t -> t
eval("If" "True" "Then" t1 "Else" t2)		= t1
eval("If" "False" "Then" t1 "Else" t2) 		= t2
eval("If" (cond:number) "Then" t1 "Else" t2)	= !error("If with a number as condition")

eval(("(" "\\" var ":" type "." t ")") arg)	= subs(var, arg, t)
eval("(" t ")")					= t

eval((n1:number) "+" (n2:number))		= plus(n1, n2)

eval((t:number) "::" "Int")			= t
eval((b:bool) "::" "Bool")			= b
eval(t[e:t])					= t[eval(e):t]

eval(t "::" type)				= !error("Invalid cast: " t " is not a " type)
eval((t : var))			 		= !error("Unresolved variable")
eval(t)						= t


# deduces a new name for the variable in an lambda abstraction
rename		: var -> var -> type -> t -> t
rename(x, newVar, type, body)
		= "(" "\\" newVar ":" type "." subs(x, newVar, body ) ")"

# replaces variable x by y in entire t
subs						: var -> t -> t -> t
subs(x, y, x)					= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )	= subs(x, y, rename(x, !newvar(x, rest), t, rest) )
subs(x, y, "(" "\\" z ":" t "." rest ")" )	= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "If" cond "Then" e1 "Else" e2)	= "If" subs(x, y, cond) "Then" subs(x, y, e1) "Else" subs(x, y, e2)
subs(x, y, t1 "+" t2)				= subs(x, y, t1) "+" subs(x, y, t2)
subs(x, y, t "::" type)				= subs(x, y, t) "::" type
subs(x, y, f arg)				= subs(x, y, f) subs(x, y, arg) 
subs(x, y, z)					= z




dom 		: type -> type
dom(t1 "->" t2) = t1

cod 		: type -> type
cod(t1 "->" t2) = t2

equate		: type -> type -> type
equate(t1, t1) = t1

# wrappers for builtin functions, as we can't type within a builtin
plus		: t -> t -> t
plus(e1, e2)	= !plus((e1:number), e2)



 Relations
===========

# (:) is reserved, as predicate that a term is of a production rule
# one can refer to rewrite rules/functions earlier on

(-->)	: t (in), t (out)	Pronounced as "evaluation"
(~~>)	: t (in), t (out)	Pronounced as "big step"
(~)	: t (in)		Pronounced as "is canonical"

(::)	: typingContext (in), t (in), type (out)	Pronounced as "has type"


 Rules
=======


	   	(n1:number)	(n2:number)
(EvalPlus) 	---------------------------
           	n1 "+" n2 --> plus(n1, n2)



(EvalIfTrue) 	--------------------------------------
              	"If" "True" "Then" t1 "Else" t2 --> t1


(EvalIfFalse) 	---------------------------------------
		"If" "False" "Then" t1 "Else" t2 --> t2


		(b:bool)
(EvalAscrBool) 	-------------------
		b "::" "Bool" --> b


		(i:number)
(EvalCastInt) 	------------------
		i "::" "Int" --> i


(EvalParens) 	---------------
		"(" t ")" --> t

	
(EvalLamApp) 	-----------------------------------------------------------
		("(" "\\" var ":" type "." t ")") arg --> subs(var, arg, t)

	   	e0 --> e
(EvalCtx) 	--------------
	    	t[e0] --> t[e]



		(b:bool)
(CanonBool) -------------
		(~) b

		(n:number)
(CanonNumber) -------------
		(~) n




          	e0 --> e1	e1 ~~> e2
(BigStepRec) --------------------------------
           	e0 ~~> e2

	 	e0 --> e1	(~) e1
(BigStepBase) -------------------------
         	e0 ~~> e1


	   	(~) e
(BigStepCanon) -----------
         	e ~~> e






	   (n:number)
(Tnumber) ----------------
	   (::) ctx, n, "Int"


	 (b:bool)
(Tbool) ------------
	 (::) ctx, b, "Bool"


	    (::) ctx, e, t
(TParens) ---------------
	   (::) ctx, "(" e ")", t


	 (::) ctx, n1, "Int"	(::) ctx, n2, "Int"
(TPlus) ---------------------------
	 (::) ctx, n1 "+" n2, "Int"


	(::) ctx, e, t
(TAscr) --------------------------------
	(::) ctx, e "::" t, t


        (::) ctx, c, "Bool"	(::) ctx, t1, t		(::) ctx, t2, t
(TIf) ---------------------------------------------------------------
	(::) ctx, "If" c "Then" t1 "Else" t2, t



	 
(Tx)	--------------------------
	 (::) typingContext[x "::" t:typing] , x, t

	   (::) ((x "::" t1) "," ctx), t, t2
(TLambda) -----------------------------------------------------------
	   (::) ctx, "(" "\\" x ":" t1 "." t ")", t1 "->" t2


	(::) ctx, e1, t1
(Tapp) -----------------------------------------------
	(::) ctx, e1 e2, cod(t1)


	x: T in $
(Tx)   ----------- 
	$ |- x: T



	






