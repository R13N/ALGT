# A simply typed functional language

 Syntax
========

# Types
typeL	::= "Int" | "Bool"
type	::= typeL "->" type | typeL


# builtins values
var	::= Identifier
number	::= Number
bool	::= "True" | "False"
t	::=  tL "+" t | tL "::" type | tL t | tL
tL	::= number | bool | var | "(" "\\" var ":" type "." t ")" | "If" t "Then" t "Else" t


 Functions
===========


# reduces one step of the logic
eval						: t -> t
eval("If" "True" "Then" t1 "Else" t2)		= t1
eval("If" "False" "Then" t1 "Else" t2) 		= t2
eval("If" (cond:number) "Then" t1 "Else" t2)	= !error("If with a number as condition")
eval("If" cond "Then" t1 "Else" t2) 		= "If" eval(cond) "Then" t1 "Else" t2

eval(("(" "\\" var ":" type "." t ")") arg)	= subs(var, arg, t)

eval(n1 "+" n2)					= plus(eval(n1), eval(n2))

eval((t:number) "::" "Int")			= t
eval("True" "::" "Bool")			= "True"
eval("False" "::" "Bool")			= "False"
eval(t "::" type)				= !error("Invalid type: " t " is not a " type)
eval((t : var))			 		= !error("Unresolved variable")
# eval(t[e:t])					= t[eval(e):t]
eval(t)						= t


# deduces a new name for the variable in an lambda abstraction
rename		: var -> var -> type -> t -> t
rename(x, newVar, type, body)
		= "(" "\\" newVar ":" type "." subs(x, newVar, body ) ")"

# replaces variable x by y in entire t
subs						: var -> t -> t -> t
subs(x, y, x)					= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )	= subs(x, y, rename(x, !newvar(x, rest), t, rest) )
subs(x, y, "(" "\\" z ":" t "." rest ")" )	= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "If" cond "Then" e1 "Else" e2)	= "If" subs(x, y, cond) "Then" subs(x, y, e1) "Else" subs(x, y, e2)
subs(x, y, t1 "+" t2)				= subs(x, y, t1) "+" subs(x, y, t2)
subs(x, y, t "::" type)				= subs(x, y, t) "::" type
subs(x, y, f arg)				= subs(x, y, f) subs(x, y, arg) 
subs(x, y, z)					= z




dom 		: type -> type
dom(t1 "->" t2) = t1

cod 		: type -> type
cod(t1 "->" t2) = t2

equate		: type -> type -> type
equate(t1, t1) = t1

# wrappers for builtin functions, as we can't type within a builtin
plus		: t -> t -> t
plus(e1, e2)	= !plus((e1:number), e2)



 Relations
===========

# (:) is reserved, as predicate that a term is of a production rule
# one can refer to rewrite rules/functions earlier on

(-->)	: t (in), t (out)	Pronounced as "evaluation"
(~~>)	: t (in), t (out)	Pronounced as "big step"
(~)	: t (in)		Pronounced as "is canonical"


 Rules
=======



		cond0 --> cond
(EvalIfCond) --------------------------------------------------------------------
		"If" cond0 "Then" t1 "Else" t2 --> "If" cond "Then" t1 "Else" t2


	    (n1:number)	(n2:number)
(EvalPlus) ---------------------------
            n1 "+" n2 --> plus(n1, n2)


	     n1 --> n2
(EvalPlusR) --------------------------
             n "+" n1 --> n "+" n2


#	    e0 --> e
# (EvalCtx) -----------------
#	    t[e0] --> t[e]




(EvalIfTrue) ------------------------------------------
              "If" "True" "Then" t1 "Else" t2 --> t1


(EvalIfFalse) ------------------------------------------
		"If" "False" "Then" t1 "Else" t2 --> t2


		(b:bool)
(EvalAscrBool) --------------------
		b "::" "Bool" --> b


		(i:number)
(EvalCastInt) ---------------------
		i "::" "Int" --> i


	
(EvalLamApp) ------------------------------------------------
		("(" "\\" var ":" type "." t ")") arg --> subs(var, arg, t)



		(b:bool)
(CanonBool) -------------
		(~) b

		(n:number)
(CanonNumber) -------------
		(~) n




          	e0 --> e1	e1 ~~> e2
(BigStepRec) --------------------------------
           	e0 ~~> e2

	 	e0 --> e1	(~) e1
(BigStepBase) -------------------------
         	e0 ~~> e1


	   	(~) e
(BigStepCanon) -----------
         	e ~~> e









	x: T in $
(Tx)   ----------- 
	$ |- x: T

(Tn)   ----------------
	$ |- number : "Int"


(TbT)   ------------------
	$ |- "True" : "Bool"


	
(TbF)  ------------------
	$ |- "False": "Bool"


	$ |- t1 : T1	$ |- t2: T2	T2 == dom(T1)
(Tapp) -----------------------------------------------
	$ |- "(" t1 t2 ")" : cod(T1)


	 $ |- t1 : T1 	$ |- t2 : T2	T1 == "Int"	T2 == "Int"
(Tplus) ------------------------------------------------------------
	 $ |- t1 "+" t2 : "Int"


 	$ |- t1 : T1 	$ |- t2 : T2	$ |- t3: T3	T1 == "Bool"
(Tif) ---------------------------------------------------------------
	$ |- "if" t1 "then" t2 "else" t3 : equate(t2, t3)


	   $, x : T1 |- t : T2
(TLambda) -----------------------------------------------------------
	   $ |- "(" "\\" x ":" T1 "." t ")" : T1 "->" T2



	 $ |- t : T	T = T1
(Tcast)	----------------------------------
	 $ |- (t "::" T1) : T1

