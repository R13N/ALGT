# A simply typed functional language

 Syntax
========

# Types
typeL	::= "Int" | "Bool"
type	::= typeL "->" type | typeL


# builtins values
var	::= Identifier
number	::= Number
bool	::= "True" | "False"
t	::=  tL "+" t | tL "::" type | tL t | tL
tL	::= number | bool | var | "(" "\\" var ":" type "." t ")" | "If" t "Then" t "Else" t | "(" t ")"


 Functions
===========


# reduces one step of the logic
eval						: t -> t
eval("If" "True" "Then" t1 "Else" t2)		= t1
eval("If" "False" "Then" t1 "Else" t2) 		= t2
eval("If" (cond:number) "Then" t1 "Else" t2)	= !error("If with a number as condition")

eval(("(" "\\" var ":" type "." t ")") arg)	= subs(var, arg, t)
eval("(" t ")")					= t

eval((n1:number) "+" (n2:number))		= plus(n1, n2)

eval((t:number) "::" "Int")			= t
eval((b:bool) "::" "Bool")			= b
eval(t[e:t])					= t[eval(e):t]

eval(t "::" type)				= !error("Invalid cast: " t " is not a " type)
eval((t : var))			 		= !error("Unresolved variable")
eval(t)						= t


# deduces a new name for the variable in an lambda abstraction
rename		: var -> var -> type -> t -> t
rename(x, newVar, type, body)
		= "(" "\\" newVar ":" type "." subs(x, newVar, body ) ")"

# replaces variable x by y in entire t
subs						: var -> t -> t -> t
subs(x, y, x)					= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )	= subs(x, y, rename(x, !newvar(x, rest), t, rest) )
subs(x, y, "(" "\\" z ":" t "." rest ")" )	= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "If" cond "Then" e1 "Else" e2)	= "If" subs(x, y, cond) "Then" subs(x, y, e1) "Else" subs(x, y, e2)
subs(x, y, t1 "+" t2)				= subs(x, y, t1) "+" subs(x, y, t2)
subs(x, y, t "::" type)				= subs(x, y, t) "::" type
subs(x, y, f arg)				= subs(x, y, f) subs(x, y, arg) 
subs(x, y, z)					= z




dom 		: type -> type
dom(t1 "->" t2) = t1

cod 		: type -> type
cod(t1 "->" t2) = t2

equate		: type -> type -> type
equate(t1, t1) = t1

# wrappers for builtin functions, as we can't type within a builtin
plus		: t -> t -> t
plus(e1, e2)	= !plus((e1:number), e2)



 Relations
===========

# (:) is reserved, as predicate that a term is of a production rule
# one can refer to rewrite rules/functions earlier on

(-->)	: t (in), t (out)	Pronounced as "evaluation"
(~~>)	: t (in), t (out)	Pronounced as "big step"
(~)	: t (in)		Pronounced as "is canonical"

(::)	: t (in), type (out)	Pronounced as "has type"


# used for testing
(!!)	: t (in), t (out)	Pronounced as "first found number"

 Rules
=======


	 	(n:number)
(NumberBase) 	----------------
		t[n:number] !! n

		(n:number)
(Number) 	----------
		n !! n



	   	(n1:number)	(n2:number)
(EvalPlus) 	---------------------------
           	n1 "+" n2 --> plus(n1, n2)



(EvalIfTrue) 	--------------------------------------
              	"If" "True" "Then" t1 "Else" t2 --> t1


(EvalIfFalse) 	---------------------------------------
		"If" "False" "Then" t1 "Else" t2 --> t2


		(b:bool)
(EvalAscrBool) 	-------------------
		b "::" "Bool" --> b


		(i:number)
(EvalCastInt) 	------------------
		i "::" "Int" --> i


(EvalParens) 	---------------
		"(" t ")" --> t

	
(EvalLamApp) 	-----------------------------------------------------------
		("(" "\\" var ":" type "." t ")") arg --> subs(var, arg, t)

	   	e0 --> e
(EvalCtx) 	--------------
	    	t[e0] --> t[e]



		(b:bool)
(CanonBool) -------------
		(~) b

		(n:number)
(CanonNumber) -------------
		(~) n




          	e0 --> e1	e1 ~~> e2
(BigStepRec) --------------------------------
           	e0 ~~> e2

	 	e0 --> e1	(~) e1
(BigStepBase) -------------------------
         	e0 ~~> e1


	   	(~) e
(BigStepCanon) -----------
         	e ~~> e






	   (n:number)
(Tnumber) ----------------
	   n :: "Int"


	 (b:bool)
(Tbool) ------------
	 b :: "Bool"


	    e :: t
(TParens) ---------------
	   "(" e ")" :: t


        c :: "Bool"	t1 :: t	     t2 :: t
(TIf) ---------------------------------------
	"If" c "Then" t1 "Else" t2 :: t


	 n1 :: "Int"	n2 :: "Int"
(TPlus) ---------------------------
	 n1 "+" n2 :: "Int"


	 e :: "Bool"
(TAscr) --------------------------------
	 e "::" "Bool" :: "Bool"




	x: T in $
(Tx)   ----------- 
	$ |- x: T



	

	$ |- t1 : T1	$ |- t2: T2	T2 == dom(T1)
(Tapp) -----------------------------------------------
	$ |- "(" t1 t2 ")" : cod(T1)


	 $ |- t1 : T1 	$ |- t2 : T2	T1 == "Int"	T2 == "Int"
(Tplus) ------------------------------------------------------------
	 $ |- t1 "+" t2 : "Int"


 	$ |- t1 : T1 	$ |- t2 : T2	$ |- t3: T3	T1 == "Bool"
(Tif) ---------------------------------------------------------------
	$ |- "if" t1 "then" t2 "else" t3 : equate(t2, t3)


	   $, x : T1 |- t : T2
(TLambda) -----------------------------------------------------------
	   $ |- "(" "\\" x ":" T1 "." t ")" : T1 "->" T2



	 $ |- t : T	T = T1
(Tcast)	----------------------------------
	 $ |- (t "::" T1) : T1

