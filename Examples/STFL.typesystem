# A simply typed functional language

 Syntax
========

# Types
typeL	::= "Int" | "Bool" | "(" type ")"
type	::= typeL "->" type | typeL


# builtins values
var	::= Identifier
number	::= Number
bool	::= "True" | "False"
e	::= eL "+" e | eL "::" type | eL e | eL
eL	::= number | bool | var | "(" "\\" var ":" type "." e ")" | "If" e "Then" e "Else" e | "(" e ")"


typing		::= var "::" type
typingContext	::= typing "," typingContext | ";"


 Functions
===========


# reduces one step of the logic
eval						: e -> e
eval("If" "True" "Then" e1 "Else" e2)		= e1
eval("If" "False" "Then" e1 "Else" e2) 		= e2
eval("If" (cond:number) "Then" e1 "Else" e2)	= !error("If with a number as condition")

eval(("(" "\\" var ":" type "." e ")") arg)	= subs(var, arg, e)
eval("(" e ")")					= e

eval((n1:number) "+" (n2:number))		= plus(n1, n2)

eval((n:number) "::" "Int")			= n
eval((b:bool) "::" "Bool")			= b
eval(expr[e])					= expr[eval(e):e]

eval(e "::" type)				= !error("Invalid cast: " e " is not a " type)
eval((e : var))			 		= !error("Unresolved variable")
eval(e)						= e


# deduces a new name for the variable in an lambda abstraction
rename		: var -> var -> type -> e -> e
rename(x, newVar, type, body)
		= "(" "\\" newVar ":" type "." subs(x, newVar, body ) ")"

# replaces variable x by y in entire expression
subs						: var -> e -> e -> e
subs(x, y, x)					= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )	= subs(x, y, rename(x, !newvar(x, rest), t, rest) )
subs(x, y, "(" "\\" z ":" t "." rest ")" )	= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "If" cond "Then" e1 "Else" e2)	= "If" subs(x, y, cond) "Then" subs(x, y, e1) "Else" subs(x, y, e2)
subs(x, y, e1 "+" e2)				= subs(x, y, e1) "+" subs(x, y, e2)
subs(x, y, e "::" type)				= subs(x, y, e) "::" type
subs(x, y, f arg)				= subs(x, y, f) subs(x, y, arg) 
subs(x, y, z)					= z




dom 		: type -> type
dom("(" T ")")	= dom(T) 
dom(T1 "->" T2) = T1

cod 		: type -> type
cod("(" T ")")	= T
cod(T1 "->" T2) = T2

equate		: type -> type -> type
equate(T, T) 	= T

# wrappers for builtin functions, as we can't type within a builtin
plus		: number -> e -> e
plus(e1, e2)	= !plus((e1:number), e2)



 Relations
===========

# (:) is reserved, as predicate that a term is of a production rule
# one can refer to rewrite rules/functions earlier on

(-->)	: e (in), e (out)	Pronounced as "evaluation"
(~~>)	: e (in), e (out)	Pronounced as "big step"
(~)	: e (in)		Pronounced as "is canonical"

(|-)	: typingContext (in), e (in), type (out)	Pronounced as "context entails typing"


 Rules
=======


	   	n1:number	n2:number
(EvalPlus) 	---------------------------
           	(n1:number) "+" n2 --> plus(n1, n2)


		
(EvalIfTrue) 	--------------------------------------
              	"If" "True" "Then" e1 "Else" e2 --> e1


(EvalIfFalse) 	---------------------------------------
		"If" "False" "Then" e1 "Else" e2 --> e2


		b:bool
(EvalAscrBool) 	-------------------
		b "::" "Bool" --> b


		i:number
(EvalCastInt) 	------------------
		i "::" "Int" --> i


(EvalParens) 	---------------
		"(" e ")" --> e

	
(EvalLamApp) 	-----------------------------------------------------------
		("(" "\\" var ":" type "." e ")") arg --> subs(var, arg, e)

	   	e0 --> e
(EvalCtx) 	--------------
	    	t[e0:e] --> t[e]



		b:bool
(CanonBool) -------------
		(~) b

		n:number
(CanonNumber) -------------
		(~) n




          	e0 --> e1	e1 ~~> e2
(BigStepRec) --------------------------------
           	e0 ~~> e2

	 	e0 --> e1	(~) e1
(BigStepBase) -------------------------
         	e0 ~~> e1


	   	(~) e
(BigStepCanon) -----------
         	e ~~> e






	   	n:number
(Tnumber) 	------------------
	  	ctx |- n, "Int"


	 	b:bool
(Tbool) 	-------------------
	 	ctx |- b, "Bool"


	    	ctx |- e, T
(TParens)	----------------------
	  	ctx |- "(" e ")", T


	 	ctx |- n1, "Int"	ctx |- n2, "Int"
(TPlus) 	-------------------------------------------
	 	ctx |- n1 "+" n2, "Int"


		ctx |- e, T
(TAscr) 	---------------------
		ctx |- e "::" T, T


       		ctx |- c, "Bool"	ctx |- e1, T		ctx |- e2, T
(TIf) 		----------------------------------------------------------------
		ctx |- "If" c "Then" e1 "Else" e2, T



(Tx)		--------------------------------------------
		typingContext[x "::" T:typing] |- x, T

	  	((x "::" T1) "," ctx) |- e, T2
(TLambda) 	-------------------------------------------------
	   	ctx |- "(" "\\" x ":" T1 "." e ")",  ( "(" T1 ")") "->" T2



		ctx |- e1, Tfunc	ctx |- e2, Targ		Targ = dom(Tfunc) : type
(Tapp) 		-------------------------------------------------------------------------
		ctx |- e1 e2, cod(Tfunc)





 Properties
============

		";" |- e0 , T	e0 --> e1
(Preservation) ---------------------------
		";" |- e1 , T


            e0:T
(Progress) ------------------
            e0 --> e1 | (~) e0
