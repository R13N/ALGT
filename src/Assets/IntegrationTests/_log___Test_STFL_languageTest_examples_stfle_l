Test/STFL.language Test/examples.stfl e -l

Warning:
  While checking the totality of function "cod":
    Following calls will fall through:
      cod("Int")
      cod("Bool")
  While checking the totality of function "dom":
    Following calls will fall through:
      dom("Int")
      dom("Bool")
  While checking the totality of function "eval":
    Following calls will fall through:
      eval(("(" "\\" var ":" type "." e ")"))
  
  While checking that the functions do have the strictest possible types:
    "dom" can be typed as "typeL", instead of a "type"
                                                                                
 Test/examples.stfl 
====================

# You didn't specify an action to perform, we'll just dump the parsetrees. See -h how to run functions
# "True" was parsed as:
"True": bool.0
# "False" was parsed as:
"False": bool.1
# "If True Then False Else True" was parsed as:
+  eL.3
|  "If": eL.3
|  "True": bool.0
|  "Then": eL.3
|  "False": bool.1
|  "Else": eL.3
|  "True": bool.0
# "If (If True Then False Else True) Then False Else True" was parsed as:
+  eL.3
|  "If": eL.3
|  +  eL.4
|  |  "(": eL.4
|  |  +  eL.3
|  |  |  "If": eL.3
|  |  |  "True": bool.0
|  |  |  "Then": eL.3
|  |  |  "False": bool.1
|  |  |  "Else": eL.3
|  |  |  "True": bool.0
|  |  ")": eL.4
|  "Then": eL.3
|  "False": bool.1
|  "Else": eL.3
|  "True": bool.0
# "42" was parsed as:
42: number.0
# "1 + 2" was parsed as:
+  e.0
|  1: number.0
|  "+": e.0
|  2: number.0
# "(\\f : Int -> Int . f 5) (\\i : Int . i + 1)" was parsed as:
+  e.2
|  +  eL.2
|  |  "(": eL.2
|  |  "\\": eL.2
|  |  "f": var.0
|  |  ":": eL.2
|  |  +  type.0
|  |  |  "Int": typeL.0
|  |  |  "->": type.0
|  |  |  "Int": typeL.0
|  |  ".": eL.2
|  |  +  e.2
|  |  |  "f": var.0
|  |  |  5: number.0
|  |  ")": eL.2
|  +  eL.2
|  |  "(": eL.2
|  |  "\\": eL.2
|  |  "i": var.0
|  |  ":": eL.2
|  |  "Int": typeL.0
|  |  ".": eL.2
|  |  +  e.0
|  |  |  "i": var.0
|  |  |  "+": e.0
|  |  |  1: number.0
|  |  ")": eL.2
# "(True)" was parsed as:
+  eL.4
|  "(": eL.4
|  "True": bool.0
|  ")": eL.4
# "False :: Bool" was parsed as:
+  e.1
|  "False": bool.1
|  "::": e.1
|  "Bool": typeL.1
# "( True )" was parsed as:
+  eL.4
|  "(": eL.4
|  "True": bool.0
|  ")": eL.4
# "(If True Then True Else True) :: Bool" was parsed as:
+  e.1
|  +  eL.4
|  |  "(": eL.4
|  |  +  eL.3
|  |  |  "If": eL.3
|  |  |  "True": bool.0
|  |  |  "Then": eL.3
|  |  |  "True": bool.0
|  |  |  "Else": eL.3
|  |  |  "True": bool.0
|  |  ")": eL.4
|  "::": e.1
|  "Bool": typeL.1
# "True" was parsed as:
"True": bool.0
# "(False)" was parsed as:
+  eL.4
|  "(": eL.4
|  "False": bool.1
|  ")": eL.4
# "True :: Bool" was parsed as:
+  e.1
|  "True": bool.0
|  "::": e.1
|  "Bool": typeL.1
# "If True Then 42 Else 43" was parsed as:
+  eL.3
|  "If": eL.3
|  "True": bool.0
|  "Then": eL.3
|  42: number.0
|  "Else": eL.3
|  43: number.0
# "If False Then 23 Else 44" was parsed as:
+  eL.3
|  "If": eL.3
|  "False": bool.1
|  "Then": eL.3
|  23: number.0
|  "Else": eL.3
|  44: number.0
# "5 + 6" was parsed as:
+  e.0
|  5: number.0
|  "+": e.0
|  6: number.0
# "5 + 6 + 7" was parsed as:
+  e.0
|  5: number.0
|  "+": e.0
|  +  e.0
|  |  6: number.0
|  |  "+": e.0
|  |  7: number.0
# "(\\x : Int . x + 1) 5" was parsed as:
+  e.2
|  +  eL.2
|  |  "(": eL.2
|  |  "\\": eL.2
|  |  "x": var.0
|  |  ":": eL.2
|  |  "Int": typeL.0
|  |  ".": eL.2
|  |  +  e.0
|  |  |  "x": var.0
|  |  |  "+": e.0
|  |  |  1: number.0
|  |  ")": eL.2
|  5: number.0
# "If (If True Then False Else True) Then 123456 Else 42" was parsed as:
+  eL.3
|  "If": eL.3
|  +  eL.4
|  |  "(": eL.4
|  |  +  eL.3
|  |  |  "If": eL.3
|  |  |  "True": bool.0
|  |  |  "Then": eL.3
|  |  |  "False": bool.1
|  |  |  "Else": eL.3
|  |  |  "True": bool.0
|  |  ")": eL.4
|  "Then": eL.3
|  123456: number.0
|  "Else": eL.3
|  42: number.0
# "5 + (6 + 7)" was parsed as:
+  e.0
|  5: number.0
|  "+": e.0
|  +  eL.4
|  |  "(": eL.4
|  |  +  e.0
|  |  |  6: number.0
|  |  |  "+": e.0
|  |  |  7: number.0
|  |  ")": eL.4
# "(5 + 6) + (7 + 8)" was parsed as:
+  e.0
|  +  eL.4
|  |  "(": eL.4
|  |  +  e.0
|  |  |  5: number.0
|  |  |  "+": e.0
|  |  |  6: number.0
|  |  ")": eL.4
|  "+": e.0
|  +  eL.4
|  |  "(": eL.4
|  |  +  e.0
|  |  |  7: number.0
|  |  |  "+": e.0
|  |  |  8: number.0
|  |  ")": eL.4
# "5 + (6 + (7 + 8))" was parsed as:
+  e.0
|  5: number.0
|  "+": e.0
|  +  eL.4
|  |  "(": eL.4
|  |  +  e.0
|  |  |  6: number.0
|  |  |  "+": e.0
|  |  |  +  eL.4
|  |  |  |  "(": eL.4
|  |  |  |  +  e.0
|  |  |  |  |  7: number.0
|  |  |  |  |  "+": e.0
|  |  |  |  |  8: number.0
|  |  |  |  ")": eL.4
|  |  ")": eL.4
# "(\\x : Int . x + 1) True" was parsed as:
+  e.2
|  +  eL.2
|  |  "(": eL.2
|  |  "\\": eL.2
|  |  "x": var.0
|  |  ":": eL.2
|  |  "Int": typeL.0
|  |  ".": eL.2
|  |  +  e.0
|  |  |  "x": var.0
|  |  |  "+": e.0
|  |  |  1: number.0
|  |  ")": eL.2
|  "True": bool.0
