Output {_files = [], _stdOut = ["Warning:\n  While checking the totality of function \"cod\":\n    Following calls will fall through:\n      cod(\"Int\")\n      cod(\"Bool\")\n  While checking the totality of function \"dom\":\n    Following calls will fall through:\n      dom(\"Int\")\n      dom(\"Bool\")\n  While checking the totality of function \"eval\":\n    Following calls will fall through:\n      eval((\"(\" \"\\\\\" var \":\" type \".\" e \")\"))\n  \n  While checking that the functions do have the strictest possible types:\n    \"dom\" can be typed as \"typeL\", instead of a \"type\"","\n Analysis for rules about (::) \n===============================\n\n# (::) \t: e (in), type (out)\tPronounced as \"type in empty context\"\n\n# Known rules are\n#   TEmptyCtx\n\nApplicable to:\n  e\nResults:\n  e0 :: typeT\n  \t where \"{}\" : typingEnvironment \8866 e0, typeT\n\n Analysis of rule \"TEmptyCtx\" \n------------------------------\n\nApplicable to:\n  e\nResults:\n  e0 :: typeT\n  \t where \"{}\" : typingEnvironment \8866 e0, typeT\n\n\n","\n Analysis for rules about (==) \n===============================\n\n# (==) \t: type (in), type (in)\tPronounced as \"equals\"\n\n# Known rules are\n#   EqBase\n#   EqParL\n#   EqParR\n#   EqArrow\n\nApplicable to:\n  type\n  (\"(\" type \")\"), type\n  type, (\"(\" type \")\")\n  (typeL \"->\" type)\nResults:\n  type0 == type0\n  (\"(\" : typeL type0:1 \")\" : typeL) : typeL == type1\n  \t where (recursion) type0:1 == type1\n  type0 == (\"(\" : typeL type1:1 \")\" : typeL) : typeL\n  \t where (recursion) type0 == type1:1\n  (typeL0:0 \"->\" : type type0:2) : type == (typeL1:0 \"->\" : type type1:2) : type\n  \t where (recursion) typeL0:0 == typeL1:0, type0:2 == type1:2\n\n Analysis of rule \"EqBase\" \n---------------------------\n\nApplicable to:\n  type\nResults:\n  type0 == type0\n\n\n\n Analysis of rule \"EqParL\" \n---------------------------\n\nApplicable to:\n  (\"(\" type \")\"), type\nResults:\n  (\"(\" : typeL type0:1 \")\" : typeL) : typeL == type1\n  \t where (recursion) type0:1 == type1\n\n\n\n Analysis of rule \"EqParR\" \n---------------------------\n\nApplicable to:\n  type, (\"(\" type \")\")\nResults:\n  type0 == (\"(\" : typeL type1:1 \")\" : typeL) : typeL\n  \t where (recursion) type0 == type1:1\n\n\n\n Analysis of rule \"EqArrow\" \n----------------------------\n\nApplicable to:\n  (typeL \"->\" type)\nResults:\n  (typeL0:0 \"->\" : type type0:2) : type == (typeL1:0 \"->\" : type type1:2) : type\n  \t where (recursion) typeL0:0 == typeL1:0, type0:2 == type1:2\n\n\n","\n Analysis for rules about (\8594) \n==============================\n\n# (\8594) \t: e (in), e (out)\tPronounced as \"evaluation\"\n\n# Known rules are\n#   EvalCtx\n#   EvalPlus\n#   EvalAscrBool\n#   EvalAscrInt\n#   EvalAscrPar\n#   EvalParens\n#   EvalIfTrue\n#   EvalIfFalse\n#   EvalLamApp\n\nApplicable to:\n  (eL \"+\" e)\n  (eL \"::\" type)\n  (eL e)\n  (\"(\" \"\\\\\" var \":\" type \".\" e \")\")\n  (\"If\" e \"Then\" e \"Else\" e)\n  (\"(\" e \")\")\n  (number \"+\" number)\n  (bool \"::\" \"Bool\")\n  (number \"::\" \"Int\")\n  (eL \"::\" (\"(\" type \")\"))\n  (\"If\" \"True\" \"Then\" e \"Else\" e)\n  (\"If\" \"False\" \"Then\" e \"Else\" e)\n  ((\"(\" \"\\\\\" var \":\" type \".\" e \")\") e)\nResults:\n  (eL0/0:0$ \"+\" : e e0/0:2) : e \8594 (ee1 \"+\" : e e0/0:2) : e\n  \t where (recursion) eL0/0:0$ \8594 ee1\n  (eL0/0:0 \"+\" : e e0/0:2$) : e \8594 (eL0/0:0 \"+\" : e ee1) : e\n  \t where (recursion) e0/0:2$ \8594 ee1\n  (eL0/1:0$ \"::\" : e type0/1:2) : e \8594 (ee1 \"::\" : e type0/1:2) : e\n  \t where (recursion) eL0/1:0$ \8594 ee1\n  (eL0/2:0$ e0/2:1) : e \8594 (ee1 e0/2:1) : e\n  \t where (recursion) eL0/2:0$ \8594 ee1\n  (eL0/2:0 e0/2:1$) : e \8594 (eL0/2:0 ee1) : e\n  \t where (recursion) e0/2:1$ \8594 ee1\n  (\"(\" : eL \"\\\\\" : eL var0/3/2:2 \":\" : eL type0/3/2:4 \".\" : eL e0/3/2:6$ \")\" : eL) : eL \8594 (\"(\" : eL \"\\\\\" : eL var0/3/2:2 \":\" : eL type0/3/2:4 \".\" : eL ee1 \")\" : eL) : eL\n  \t where (recursion) e0/3/2:6$ \8594 ee1\n  (\"If\" : eL e0/3/3:1$ \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5) : eL \8594 (\"If\" : eL ee1 \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5) : eL\n  \t where (recursion) e0/3/3:1$ \8594 ee1\n  (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3$ \"Else\" : eL e0/3/3:5) : eL \8594 (\"If\" : eL e0/3/3:1 \"Then\" : eL ee1 \"Else\" : eL e0/3/3:5) : eL\n  \t where (recursion) e0/3/3:3$ \8594 ee1\n  (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5$) : eL \8594 (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3 \"Else\" : eL ee1) : eL\n  \t where (recursion) e0/3/3:5$ \8594 ee1\n  (\"(\" : eL e0/3/4:1$ \")\" : eL) : eL \8594 (\"(\" : eL ee1 \")\" : eL) : eL\n  \t where (recursion) e0/3/4:1$ \8594 ee1\n  (number0:0 \"+\" : e number0:2) : e \8594 number (Function call - ID not retrievable)\n  (bool0:0 \"::\" : e \"Bool\" : typeL) : e \8594 bool0:0\n  (number0:0 \"::\" : e \"Int\" : typeL) : e \8594 number0:0\n  (eL0:0 \"::\" : e (\"(\" : typeL type0:2:1 \")\" : typeL) : typeL) : e \8594 eL0:0\n  \t where (recursion) (eL0:0 \"::\" : e type0:2:1) : e \8594 eL0:0\n  (\"(\" : eL e0:1 \")\" : eL) : eL \8594 e0:1\n  (\"If\" : eL \"True\" : bool \"Then\" : eL e0:3 \"Else\" : eL e0:5) : eL \8594 e0:3\n  (\"If\" : eL \"False\" : bool \"Then\" : eL e0:3 \"Else\" : eL e0:5) : eL \8594 e0:5\n  ((\"(\" : eL \"\\\\\" : eL var0:0:2 \":\" : eL type0:0:4 \".\" : eL e0:0:6 \")\" : eL) : eL e0:1) : e \8594 e (Function call - ID not retrievable)\n\n Analysis of rule \"EvalCtx\" \n----------------------------\n\nApplicable to:\n  (eL \"+\" e)\n  (eL \"::\" type)\n  (eL e)\n  (\"(\" \"\\\\\" var \":\" type \".\" e \")\")\n  (\"If\" e \"Then\" e \"Else\" e)\n  (\"(\" e \")\")\nResults:\n  (eL0/0:0$ \"+\" : e e0/0:2) : e \8594 (ee1 \"+\" : e e0/0:2) : e\n  \t where (recursion) eL0/0:0$ \8594 ee1\n  (eL0/0:0 \"+\" : e e0/0:2$) : e \8594 (eL0/0:0 \"+\" : e ee1) : e\n  \t where (recursion) e0/0:2$ \8594 ee1\n  (eL0/1:0$ \"::\" : e type0/1:2) : e \8594 (ee1 \"::\" : e type0/1:2) : e\n  \t where (recursion) eL0/1:0$ \8594 ee1\n  (eL0/2:0$ e0/2:1) : e \8594 (ee1 e0/2:1) : e\n  \t where (recursion) eL0/2:0$ \8594 ee1\n  (eL0/2:0 e0/2:1$) : e \8594 (eL0/2:0 ee1) : e\n  \t where (recursion) e0/2:1$ \8594 ee1\n  (\"(\" : eL \"\\\\\" : eL var0/3/2:2 \":\" : eL type0/3/2:4 \".\" : eL e0/3/2:6$ \")\" : eL) : eL \8594 (\"(\" : eL \"\\\\\" : eL var0/3/2:2 \":\" : eL type0/3/2:4 \".\" : eL ee1 \")\" : eL) : eL\n  \t where (recursion) e0/3/2:6$ \8594 ee1\n  (\"If\" : eL e0/3/3:1$ \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5) : eL \8594 (\"If\" : eL ee1 \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5) : eL\n  \t where (recursion) e0/3/3:1$ \8594 ee1\n  (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3$ \"Else\" : eL e0/3/3:5) : eL \8594 (\"If\" : eL e0/3/3:1 \"Then\" : eL ee1 \"Else\" : eL e0/3/3:5) : eL\n  \t where (recursion) e0/3/3:3$ \8594 ee1\n  (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3 \"Else\" : eL e0/3/3:5$) : eL \8594 (\"If\" : eL e0/3/3:1 \"Then\" : eL e0/3/3:3 \"Else\" : eL ee1) : eL\n  \t where (recursion) e0/3/3:5$ \8594 ee1\n  (\"(\" : eL e0/3/4:1$ \")\" : eL) : eL \8594 (\"(\" : eL ee1 \")\" : eL) : eL\n  \t where (recursion) e0/3/4:1$ \8594 ee1\n\n\n\n Analysis of rule \"EvalPlus\" \n-----------------------------\n\nApplicable to:\n  (number \"+\" number)\nResults:\n  (number0:0 \"+\" : e number0:2) : e \8594 number (Function call - ID not retrievable)\n\n\n\n Analysis of rule \"EvalAscrBool\" \n---------------------------------\n\nApplicable to:\n  (bool \"::\" \"Bool\")\nResults:\n  (bool0:0 \"::\" : e \"Bool\" : typeL) : e \8594 bool0:0\n\n\n\n Analysis of rule \"EvalAscrInt\" \n--------------------------------\n\nApplicable to:\n  (number \"::\" \"Int\")\nResults:\n  (number0:0 \"::\" : e \"Int\" : typeL) : e \8594 number0:0\n\n\n\n Analysis of rule \"EvalAscrPar\" \n--------------------------------\n\nApplicable to:\n  (eL \"::\" (\"(\" type \")\"))\nResults:\n  (eL0:0 \"::\" : e (\"(\" : typeL type0:2:1 \")\" : typeL) : typeL) : e \8594 eL0:0\n  \t where (recursion) (eL0:0 \"::\" : e type0:2:1) : e \8594 eL0:0\n\n\n\n Analysis of rule \"EvalParens\" \n-------------------------------\n\nApplicable to:\n  (\"(\" e \")\")\nResults:\n  (\"(\" : eL e0:1 \")\" : eL) : eL \8594 e0:1\n\n\n\n Analysis of rule \"EvalIfTrue\" \n-------------------------------\n\nApplicable to:\n  (\"If\" \"True\" \"Then\" e \"Else\" e)\nResults:\n  (\"If\" : eL \"True\" : bool \"Then\" : eL e0:3 \"Else\" : eL e0:5) : eL \8594 e0:3\n\n\n\n Analysis of rule \"EvalIfFalse\" \n--------------------------------\n\nApplicable to:\n  (\"If\" \"False\" \"Then\" e \"Else\" e)\nResults:\n  (\"If\" : eL \"False\" : bool \"Then\" : eL e0:3 \"Else\" : eL e0:5) : eL \8594 e0:5\n\n\n\n Analysis of rule \"EvalLamApp\" \n-------------------------------\n\nApplicable to:\n  ((\"(\" \"\\\\\" var \":\" type \".\" e \")\") e)\nResults:\n  ((\"(\" : eL \"\\\\\" : eL var0:0:2 \":\" : eL type0:0:4 \".\" : eL e0:0:6 \")\" : eL) : eL e0:1) : e \8594 e (Function call - ID not retrievable)\n\n\n","\n Analysis for rules about (\8594*) \n===============================\n\n# (\8594*) \t: e (in), e (out)\tPronounced as \"big step\"\n\n# Known rules are\n#   BigStepCanon\n#   BigStepRec\n#   BigStepBase\n\nApplicable to:\n  e\nResults:\n  e0 \8594* e0\n  \t where (\10003) e0\n  e0 \8594* ee2\n  \t where (recursion) e0 \8594 ee1, ee1 \8594* ee2\n  e0 \8594* ee1\n  \t where e0 \8594 ee1, (\10003) ee1\n\n Analysis of rule \"BigStepCanon\" \n---------------------------------\n\nApplicable to:\n  e\nResults:\n  e0 \8594* e0\n  \t where (\10003) e0\n\n\n\n Analysis of rule \"BigStepRec\" \n-------------------------------\n\nApplicable to:\n  e\nResults:\n  e0 \8594* ee2\n  \t where (recursion) e0 \8594 ee1, ee1 \8594* ee2\n\n\n\n Analysis of rule \"BigStepBase\" \n--------------------------------\n\nApplicable to:\n  e\nResults:\n  e0 \8594* ee1\n  \t where e0 \8594 ee1, (\10003) ee1\n\n\n","\n Analysis for rules about (\8866) \n==============================\n\n# (\8866) \t: typingEnvironment (in), e (in), type (out)\tPronounced as \"context entails typing\"\n\n# Known rules are\n#   Tnumber\n#   Tbool\n#   TParens\n#   TAscr\n#   Tx\n#   TPlus\n#   TIf\n#   TLambda\n#   Tapp\n\nApplicable to:\n  typingEnvironment, number\n  typingEnvironment, bool\n  typingEnvironment, (\"(\" e \")\")\n  typingEnvironment, (eL \"::\" type)\n  typingEnvironment, (eL \"+\" e)\n  typingEnvironment, (\"If\" e \"Then\" e \"Else\" e)\n  typingEnvironment, (\"(\" \"\\\\\" var \":\" type \".\" e \")\")\n  typingEnvironment, (eL e)\nResults:\n  typingEnvironment0 \8866 number1, \"Int\" : typeL\n  typingEnvironment0 \8866 bool1, \"Bool\" : typeL\n  typingEnvironment0 \8866 (\"(\" : eL e1:1 \")\" : eL) : eL, typeT\n  \t where (recursion) typingEnvironment0 \8866 e1:1, typeT\n  typingEnvironment0 \8866 (eL1:0 \"::\" : e type1:2) : e, typeT'\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, typeT', typeT' == type1:2\n  typingEnvironment0 \8866 (eL1:0 \"+\" : e e1:2) : e, \"Int\" : typeL\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, \"Int\" : typeL, typingEnvironment0 \8866 e1:2, \"Int\" : typeL\n  typingEnvironment0 \8866 (\"If\" : eL e1:1 \"Then\" : eL e1:3 \"Else\" : eL e1:5) : eL, typeTl\n  \t where (recursion) typingEnvironment0 \8866 e1:1, \"Bool\" : typeL, typingEnvironment0 \8866 e1:3, typeTl, typingEnvironment0 \8866 e1:5, typeTr, typeTl == typeTr\n  typingEnvironment0 \8866 (\"(\" : eL \"\\\\\" : eL var1:2 \":\" : eL type1:4 \".\" : eL e1:6 \")\" : eL) : eL, ((\"(\" : typeL type1:4 \")\" : typeL) : typeL \"->\" : type typeT2) : type\n  \t where (recursion) ((var1:2 \":\" : typing type1:4) : typing \",\" : typingEnvironment typingEnvironment0) : typingEnvironment \8866 e1:6, typeT2\n  typingEnvironment0 \8866 (eL1:0 e1:1) : e, type (Function call - ID not retrievable)\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, typeTfunc, typingEnvironment0 \8866 e1:1, typeTarg, typeTarg == type (Function call - ID not retrievable)\n\n Analysis of rule \"Tnumber\" \n----------------------------\n\nApplicable to:\n  typingEnvironment, number\nResults:\n  typingEnvironment0 \8866 number1, \"Int\" : typeL\n\n\n\n Analysis of rule \"Tbool\" \n--------------------------\n\nApplicable to:\n  typingEnvironment, bool\nResults:\n  typingEnvironment0 \8866 bool1, \"Bool\" : typeL\n\n\n\n Analysis of rule \"TParens\" \n----------------------------\n\nApplicable to:\n  typingEnvironment, (\"(\" e \")\")\nResults:\n  typingEnvironment0 \8866 (\"(\" : eL e1:1 \")\" : eL) : eL, typeT\n  \t where (recursion) typingEnvironment0 \8866 e1:1, typeT\n\n\n\n Analysis of rule \"TAscr\" \n--------------------------\n\nApplicable to:\n  typingEnvironment, (eL \"::\" type)\nResults:\n  typingEnvironment0 \8866 (eL1:0 \"::\" : e type1:2) : e, typeT'\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, typeT', typeT' == type1:2\n\n\n\n Analysis of rule \"Tx\" \n-----------------------\n\nApplicable to:\n\nResults:\n\n\n\n\n Analysis of rule \"TPlus\" \n--------------------------\n\nApplicable to:\n  typingEnvironment, (eL \"+\" e)\nResults:\n  typingEnvironment0 \8866 (eL1:0 \"+\" : e e1:2) : e, \"Int\" : typeL\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, \"Int\" : typeL, typingEnvironment0 \8866 e1:2, \"Int\" : typeL\n\n\n\n Analysis of rule \"TIf\" \n------------------------\n\nApplicable to:\n  typingEnvironment, (\"If\" e \"Then\" e \"Else\" e)\nResults:\n  typingEnvironment0 \8866 (\"If\" : eL e1:1 \"Then\" : eL e1:3 \"Else\" : eL e1:5) : eL, typeTl\n  \t where (recursion) typingEnvironment0 \8866 e1:1, \"Bool\" : typeL, typingEnvironment0 \8866 e1:3, typeTl, typingEnvironment0 \8866 e1:5, typeTr, typeTl == typeTr\n\n\n\n Analysis of rule \"TLambda\" \n----------------------------\n\nApplicable to:\n  typingEnvironment, (\"(\" \"\\\\\" var \":\" type \".\" e \")\")\nResults:\n  typingEnvironment0 \8866 (\"(\" : eL \"\\\\\" : eL var1:2 \":\" : eL type1:4 \".\" : eL e1:6 \")\" : eL) : eL, ((\"(\" : typeL type1:4 \")\" : typeL) : typeL \"->\" : type typeT2) : type\n  \t where (recursion) ((var1:2 \":\" : typing type1:4) : typing \",\" : typingEnvironment typingEnvironment0) : typingEnvironment \8866 e1:6, typeT2\n\n\n\n Analysis of rule \"Tapp\" \n-------------------------\n\nApplicable to:\n  typingEnvironment, (eL e)\nResults:\n  typingEnvironment0 \8866 (eL1:0 e1:1) : e, type (Function call - ID not retrievable)\n  \t where (recursion) typingEnvironment0 \8866 eL1:0, typeTfunc, typingEnvironment0 \8866 e1:1, typeTarg, typeTarg == type (Function call - ID not retrievable)\n\n\n","\n Analysis for rules about (\10003) \n==============================\n\n# (\10003) \t: e (in)\tPronounced as \"is canonical\"\n\n# Known rules are\n#   CanonBool\n#   CanonNumber\n\nApplicable to:\n  bool\n  number\nResults:\n  (\10003) bool0\n  (\10003) number0\n\n Analysis of rule \"CanonBool\" \n------------------------------\n\nApplicable to:\n  bool\nResults:\n  (\10003) bool0\n\n\n\n Analysis of rule \"CanonNumber\" \n--------------------------------\n\nApplicable to:\n  number\nResults:\n  (\10003) number0\n\n\n","\n Relation analysis of STFL \n===========================\n\nFollowing new types were introduced:\n  !(e)(\8594)in0 \t(derived from e)\n  (e)(\8594)in0 \t(derived from e)\n  !(e)(\8866)in1 \t(derived from e)\n  (e)(\8866)in1 \t(derived from e)\n  !(eL)(\8594)in0 \t(derived from eL)\n  (eL)(\8594)in0 \t(derived from eL)\n  !(eL)(\8866)in1 \t(derived from eL)\n  (eL)(\8866)in1 \t(derived from eL)\n  !(typeL)(==)in0 \t(derived from typeL)\n  (typeL)(==)in0 \t(derived from typeL)\n  !(typeL)(==)in1 \t(derived from typeL)\n  (typeL)(==)in1 \t(derived from typeL)\n\nFollowing types were ommitted, as they turned out to coincide with some other type:\n  ((e)(\8594)in0)(\8594*)in0 \t== (e)(\8594)in0\n  ((e)(\8866)in1)(::)in0 \t== (e)(\8866)in1\n  ((e)(\10003)in0)(\8594*)in0 \t== (e)(\10003)in0\n  ((type)(==)in0)(==)in0 \t== (type)(==)in0\n  ((type)(==)in1)(==)in1 \t== (type)(==)in1\n  ((typingEnvironment)(\8866)in0)(\8866)in0 \t== (typingEnvironment)(\8866)in0\n  (bool)(\8866)in1 \t== bool\n  (bool)(\10003)in0 \t== bool\n  (e)(::)in0 \t== (eL)(::)in0\n  (e)(\8594*)in0 \t== (eL)(\8594*)in0\n  (e)(\10003)in0 \t== (eL)(\10003)in0\n  (eL)(::)in0 \t== (value)(::)in0\n  (eL)(\8594*)in0 \t== (value)(\8594*)in0\n  (eL)(\10003)in0 \t== (value)(\10003)in0\n  (number)(\8866)in1 \t== number\n  (number)(\10003)in0 \t== number\n  (type)(==)in0 \t== type\n  (type)(==)in1 \t== type\n  (typingEnvironment)(\8866)in0 \t== typingEnvironment\n  (value)(\8866)in1 \t== value\n  (value)(\10003)in0 \t== value\n\nFollowing types were omitted, as they turned out to be empty. They might cause 'dissapearing' choices in other rules:\n  (value)(::)in0\n  (value)(\8594)in0\n  (value)(\8594*)in0\n  (bool)(::)in0\n  (bool)(\8594)in0\n  (bool)(\8594*)in0\n  (number)(::)in0\n  (number)(\8594)in0\n  (number)(\8594*)in0\n  (var)(::)in0\n  (var)(\8594)in0\n  (var)(\8594*)in0\n  (var)(\8866)in1\n  (var)(\10003)in0\n\n!(e)(\8594)in0 has following subtypes:  !(eL)(\8594)in0\n  eL\n!(e)(\8866)in1 has following subtypes:  !(eL)(\8866)in1\n  eL\n!(eL)(\8594)in0 has following subtypes:  value\n  var\n!(eL)(\8866)in1 has following subtypes:  value\n  var\n!(typeL)(==)in0 has following subtypes:  \603\n!(typeL)(==)in1 has following subtypes:  \603\n(e)(\8594)in0 has following subtypes:  (eL)(\8594)in0\n(e)(\8866)in1 has following subtypes:  (eL)(\8866)in1\n(eL)(\8594)in0 has following subtypes:  \603\n(eL)(\8866)in1 has following subtypes:  value\n(typeL)(==)in0 has following subtypes:  \603\n(typeL)(==)in1 has following subtypes:  \603\nbool has following subtypes:  \603\ne has following subtypes:  !(e)(\8594)in0\n  !(e)(\8866)in1\n  (e)(\8594)in0\n  (e)(\8866)in1\n  eL\neL has following subtypes:  !(eL)(\8594)in0\n  !(eL)(\8866)in1\n  (eL)(\8594)in0\n  (eL)(\8866)in1\n  value\n  var\nnumber has following subtypes:  \603\ntype has following subtypes:  typeL\ntypeL has following subtypes:  !(typeL)(==)in0\n  !(typeL)(==)in1\n  (typeL)(==)in0\n  (typeL)(==)in1\n  \603\ntyping has following subtypes:  \603\ntypingEnvironment has following subtypes:  \603\nvalue has following subtypes:  bool\n  number\nvar has following subtypes:  \603\n\603 has following subtypes:\n\n Resulting Syntax \n------------------\n\n!(e)(\8594)in0       ::= !(eL)(\8594)in0 \"+\" !(e)(\8594)in0\n                 | !(eL)(\8594)in0 \"::\" type\n                 | !(eL)(\8594)in0 !(e)(\8594)in0\n                 | !(eL)(\8594)in0\n                 | bool \"+\" e\n                 | var \"+\" e\n                 | \"If\" e \"Then\" e \"Else\" e \"+\" e\n                 | \"(\" e \")\" \"+\" e\n                 | eL \"+\" eL \"+\" e\n                 | eL \"+\" eL \"::\" type\n                 | eL \"+\" eL e\n                 | eL \"+\" bool\n                 | eL \"+\" var\n                 | eL \"+\" \"(\" \"\\\\\" var \":\" type \".\" e \")\"\n                 | eL \"+\" \"If\" e \"Then\" e \"Else\" e\n                 | eL \"+\" \"(\" e \")\"\n                 | number \"::\" type\n                 | var \"::\" type\n                 | \"If\" e \"Then\" e \"Else\" e \"::\" type\n                 | \"(\" e \")\" \"::\" type\n                 | bool \"::\" type\n                 | eL \"::\" type\n                 | eL e\n                 | eL\n!(e)(\8866)in1       ::= !(eL)(\8866)in1 \"+\" e\n                 | eL \"+\" !(e)(\8866)in1\n                 | !(eL)(\8866)in1 \"::\" type\n                 | !(eL)(\8866)in1 e\n                 | eL !(e)(\8866)in1\n                 | !(eL)(\8866)in1\n                 | eL \"+\" e\n                 | eL \"::\" type\n                 | eL e\n                 | eL\n!(eL)(\8594)in0      ::= value\n                 | var\n                 | \"(\" \"\\\\\" var \":\" type \".\" !(e)(\8594)in0 \")\"\n                 | \"If\" !(e)(\8594)in0 \"Then\" !(e)(\8594)in0 \"Else\" !(e)(\8594)in0\n                 | \"(\" e \")\"\n                 | value\n                 | var\n                 | \"(\" \"\\\\\" var \":\" type \".\" e \")\"\n                 | \"If\" eL \"+\" e \"Then\" e \"Else\" e\n                 | \"If\" eL \"::\" type \"Then\" e \"Else\" e\n                 | \"If\" eL e \"Then\" e \"Else\" e\n                 | \"If\" number \"Then\" e \"Else\" e\n                 | \"If\" var \"Then\" e \"Else\" e\n                 | \"If\" \"(\" \"\\\\\" var \":\" type \".\" e \")\" \"Then\" e \"Else\" e\n                 | \"If\" \"If\" e \"Then\" e \"Else\" e \"Then\" e \"Else\" e\n                 | \"If\" \"(\" e \")\" \"Then\" e \"Else\" e\n!(eL)(\8866)in1      ::= value\n                 | var\n                 | \"(\" \"\\\\\" var \":\" type \".\" !(e)(\8866)in1 \")\"\n                 | \"If\" !(e)(\8866)in1 \"Then\" e \"Else\" e\n                 | \"If\" e \"Then\" !(e)(\8866)in1 \"Else\" e\n                 | \"If\" e \"Then\" e \"Else\" !(e)(\8866)in1\n                 | \"(\" !(e)(\8866)in1 \")\"\n                 | var\n                 | \"(\" \"\\\\\" var \":\" type \".\" e \")\"\n                 | \"If\" e \"Then\" e \"Else\" e\n                 | \"(\" e \")\"\n!(typeL)(==)in0  ::= \"Int\"\n                 | \"Bool\"\n                 | \"(\" type \")\"\n                 | \"Int\"\n                 | \"Bool\"\n!(typeL)(==)in1  ::= \"Int\"\n                 | \"Bool\"\n                 | \"(\" type \")\"\n                 | \"Int\"\n                 | \"Bool\"\n(e)(\8594)in0        ::= (eL)(\8594)in0\n                 | (eL)(\8594)in0 e\n                 | (eL)(\8594)in0 \"+\" e\n                 | (eL)(\8594)in0 \"::\" type\n                 | bool \"::\" \"Bool\"\n                 | eL (e)(\8594)in0\n                 | eL \"+\" (e)(\8594)in0\n                 | eL \"::\" \"(\" type \")\"\n                 | number \"+\" number\n                 | number \"::\" \"Int\"\n                 | \"(\" \"\\\\\" var \":\" type \".\" e \")\" e\n(e)(\8866)in1        ::= (eL)(\8866)in1\n                 | (eL)(\8866)in1 (e)(\8866)in1\n                 | (eL)(\8866)in1 \"+\" (e)(\8866)in1\n                 | (eL)(\8866)in1 \"::\" type\n(eL)(\8594)in0       ::= \"(\" e \")\"\n                 | \"(\" \"\\\\\" var \":\" type \".\" (e)(\8594)in0 \")\"\n                 | \"If\" (e)(\8594)in0 \"Then\" e \"Else\" e\n                 | \"If\" bool \"Then\" e \"Else\" e\n                 | \"If\" e \"Then\" (e)(\8594)in0 \"Else\" e\n                 | \"If\" e \"Then\" e \"Else\" (e)(\8594)in0\n(eL)(\8866)in1       ::= value\n                 | \"(\" (e)(\8866)in1 \")\"\n                 | \"(\" \"\\\\\" var \":\" type \".\" (e)(\8866)in1 \")\"\n                 | \"If\" (e)(\8866)in1 \"Then\" (e)(\8866)in1 \"Else\" (e)(\8866)in1\n(typeL)(==)in0   ::= \"(\" type \")\"\n(typeL)(==)in1   ::= \"(\" type \")\"\nbool             ::= \"True\"\n                 | \"False\"\ne                ::= eL \"+\" e\n                 | eL \"::\" type\n                 | eL e\n                 | eL\neL               ::= value\n                 | var\n                 | \"(\" \"\\\\\" var \":\" type \".\" e \")\"\n                 | \"If\" e \"Then\" e \"Else\" e\n                 | \"(\" e \")\"\nnumber           ::= Number\ntype             ::= typeL \"->\" type\n                 | typeL\ntypeL            ::= \"Int\"\n                 | \"Bool\"\n                 | \"(\" type \")\"\ntyping           ::= var \":\" type\ntypingEnvironment::= typing \",\" typingEnvironment\n                 | \"{}\"\nvalue            ::= bool\n                 | number\nvar              ::= Identifier\n\n\n\n# Run --irasvg PATH.svg to generate a nice svg about the subtyping relationsships"]}