Test/STFL.language --ira

Warning:
  While checking the totality of function "cod":
    Following calls will fall through:
      cod("Bool")
      cod("Int")
  While checking the totality of function "dom":
    Following calls will fall through:
      dom("Bool")
      dom("Int")
  While checking the totality of function "equate":
    Following calls will fall through:
      equate(type, type)
  While checking the totality of function "eval":
    Following calls will fall through:
      eval(("(" "\\" var ":" type "." e ")"))
  
  While checking liveability of every clause in function "subs":
    subs(x, y, "(" e ")")    = "(" subs(x, y, e) ")" will never match anything, as the possible arguments are already consumed
  

 Relation analysis of STFL 
===========================

Following new types were introduced:
  !(e)(→)in0 	(derived from e)
  (e)(→)in0 	(derived from e)
  !(e)(⊢)in1 	(derived from e)
  (e)(⊢)in1 	(derived from e)
  !(eL)(→)in0 	(derived from eL)
  (eL)(→)in0 	(derived from eL)
  !(eL)(⊢)in1 	(derived from eL)
  (eL)(⊢)in1 	(derived from eL)
  !(typeL)(==)in0 	(derived from typeL)
  (typeL)(==)in0 	(derived from typeL)
  !(typeL)(==)in1 	(derived from typeL)
  (typeL)(==)in1 	(derived from typeL)
  (value)(⊢)in1 	(derived from value)
  (value)(✓)in0 	(derived from value)

Following types were ommitted, as they turned out to coincide with some other type:
  ((e)(→)in0)(→*)in0 	== (e)(→)in0
  ((e)(⊢)in1)(::)in0 	== (e)(⊢)in1
  ((e)(✓)in0)(→*)in0 	== (e)(✓)in0
  ((type)(==)in0)(==)in0 	== (type)(==)in0
  ((type)(==)in1)(==)in1 	== (type)(==)in1
  ((typingEnvironment)(⊢)in0)(⊢)in0 	== (typingEnvironment)(⊢)in0
  (bool)(⊢)in1 	== bool
  (bool)(✓)in0 	== bool
  (e)(::)in0 	== (eL)(::)in0
  (e)(→*)in0 	== (eL)(→*)in0
  (e)(✓)in0 	== (eL)(✓)in0
  (eL)(::)in0 	== (value)(::)in0
  (eL)(→*)in0 	== (value)(→*)in0
  (eL)(✓)in0 	== (value)(✓)in0
  (number)(⊢)in1 	== number
  (number)(✓)in0 	== number
  (type)(==)in0 	== type
  (type)(==)in1 	== type
  (typingEnvironment)(⊢)in0 	== typingEnvironment

Following types were omitted, as they turned out to be empty. They might cause 'dissapearing' choices in other rules:
  !(value)(⊢)in1
  !(value)(✓)in0
  (value)(::)in0
  (value)(→)in0
  (value)(→*)in0
  (bool)(::)in0
  (bool)(→)in0
  (bool)(→*)in0
  (number)(::)in0
  (number)(→)in0
  (number)(→*)in0
  (var)(::)in0
  (var)(→)in0
  (var)(→*)in0
  (var)(⊢)in1
  (var)(✓)in0

!(e)(→)in0 has following subtypes:  !(eL)(→)in0
!(e)(⊢)in1 has following subtypes:  !(eL)(⊢)in1
!(eL)(→)in0 has following subtypes:  value
  var
!(eL)(⊢)in1 has following subtypes:  var
(e)(→)in0 has following subtypes:  (eL)(→)in0
(e)(⊢)in1 has following subtypes:  (eL)(⊢)in1
(eL)(⊢)in1 has following subtypes:  (value)(⊢)in1
(value)(⊢)in1 has following subtypes:  bool
  number
(value)(✓)in0 has following subtypes:  bool
  number
e has following subtypes:  !(e)(→)in0
  !(e)(⊢)in1
  (e)(→)in0
  (e)(⊢)in1
  eL
eL has following subtypes:  !(eL)(→)in0
  !(eL)(⊢)in1
  (eL)(→)in0
  (eL)(⊢)in1
  value
  var
type has following subtypes:  typeL
typeL has following subtypes:  !(typeL)(==)in0
  !(typeL)(==)in1
  (typeL)(==)in0
  (typeL)(==)in1
value has following subtypes:  (value)(⊢)in1
  (value)(✓)in0
  bool
  number


 Resulting Syntax 
------------------

!(e)(→)in0       ::= !(eL)(→)in0
                 | !(eL)(→)in0 "+" var
                 | !(eL)(→)in0 "+" bool
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "+" !(e)(→)in0
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "::" type
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "::" "Bool"
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "::" "Int"
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "::" typeL "->" type
                 | !(eL)(→)in0 "+" !(eL)(→)in0 "::" "(" type ")"
                 | !(eL)(→)in0 "+" "(" "\\" var ":" type "." !(e)(→)in0 ")"
                 | !(eL)(→)in0 "+" "If" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | var "+" !(e)(→)in0
                 | bool "+" !(e)(→)in0
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "+" !(e)(→)in0
                 | "If" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0 "+" !(e)(→)in0
                 | !(eL)(→)in0 "::" typeL "->" type
                 | !(eL)(→)in0 "::" "(" type ")"
                 | var "::" type
                 | var "::" "Bool"
                 | var "::" "Int"
                 | var "::" typeL "->" type
                 | var "::" "(" type ")"
                 | bool "::" "Int"
                 | bool "::" typeL "->" type
                 | bool "::" "(" type ")"
                 | number "::" "Bool"
                 | number "::" typeL "->" type
                 | number "::" "(" type ")"
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "::" type
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "::" "Bool"
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "::" "Int"
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "::" typeL "->" type
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")" "::" "(" type ")"
                 | "If" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0 "::" type
                 | "If" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0 "::" "Int"
                 | !(eL)(→)in0 !(e)(→)in0
!(e)(⊢)in1       ::= !(eL)(⊢)in1
                 | !(eL)(⊢)in1 "+" e
                 | eL "+" !(e)(⊢)in1
                 | !(eL)(⊢)in1 "::" type
                 | !(eL)(⊢)in1 e
                 | eL !(e)(⊢)in1
!(eL)(→)in0      ::= value
                 | var
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")"
                 | "If" var "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" number "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "+" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "::" type "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "::" "Bool" "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "::" "Int" "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "::" typeL "->" type "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" !(eL)(→)in0 "::" "(" type ")" "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" "(" "\\" var ":" type "." !(e)(→)in0 ")" "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" "If" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0 "Then" !(e)(→)in0 "Else" !(e)(→)in0
!(eL)(⊢)in1      ::= var
                 | "(" "\\" var ":" type "." !(e)(⊢)in1 ")"
                 | "If" !(e)(⊢)in1 "Then" e "Else" e
                 | "If" e "Then" !(e)(⊢)in1 "Else" e
                 | "If" e "Then" e "Else" !(e)(⊢)in1
                 | "(" !(e)(⊢)in1 ")"
!(typeL)(==)in0  ::= "Bool"
                 | "Int"
!(typeL)(==)in1  ::= "Bool"
                 | "Int"
(e)(→)in0        ::= (eL)(→)in0
                 | (eL)(→)in0 "+" e
                 | eL "+" (e)(→)in0
                 | number "+" number
                 | (eL)(→)in0 "::" type
                 | bool "::" "Bool"
                 | eL "::" "(" type ")"
                 | number "::" "Int"
                 | (eL)(→)in0 e
                 | eL (e)(→)in0
                 | "(" "\\" var ":" type "." e ")" e
(e)(⊢)in1        ::= (eL)(⊢)in1
                 | (eL)(⊢)in1 "+" (e)(⊢)in1
                 | (eL)(⊢)in1 "::" type
                 | (eL)(⊢)in1 (e)(⊢)in1
(eL)(→)in0       ::= "(" "\\" var ":" type "." (e)(→)in0 ")"
                 | "If" (e)(→)in0 "Then" e "Else" e
                 | "If" bool "Then" e "Else" e
                 | "If" e "Then" (e)(→)in0 "Else" e
                 | "If" e "Then" e "Else" (e)(→)in0
                 | "(" e ")"
(eL)(⊢)in1       ::= (value)(⊢)in1
                 | "(" "\\" var ":" type "." (e)(⊢)in1 ")"
                 | "If" (e)(⊢)in1 "Then" (e)(⊢)in1 "Else" (e)(⊢)in1
                 | "(" (e)(⊢)in1 ")"
(typeL)(==)in0   ::= "(" type ")"
(typeL)(==)in1   ::= "(" type ")"
(value)(⊢)in1    ::= bool
                 | number
(value)(✓)in0    ::= bool
                 | number
bool             ::= "True"
                 | "False"
e                ::= eL "+" e
                 | eL "::" type
                 | eL e
                 | eL
eL               ::= value
                 | var
                 | "(" "\\" var ":" type "." e ")"
                 | "If" e "Then" e "Else" e
                 | "(" e ")"
number           ::= Number
type             ::= typeL "->" type
                 | typeL
typeL            ::= "Int"
                 | "Bool"
                 | "(" type ")"
typing           ::= var ":" type
typingEnvironment::= typing "," typingEnvironment
                 | "{}"
value            ::= bool
                 | number
var              ::= Identifier


# Run --irasvg PATH.svg to generate a nice svg about the subtyping relationsships
