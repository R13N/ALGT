Test/STFL.language --ira

Warning:
  While checking the totality of function "cod":
    Following calls will fall through:
      cod("Bool")
      cod("Int")
  While checking the totality of function "dom":
    Following calls will fall through:
      dom("Bool")
      dom("Int")
  While checking the totality of function "equate":
    Following calls will fall through:
      equate(type, type)
  While checking the totality of function "eval":
    Following calls will fall through:
      eval(("(" "\\" var ":" type "." e ")"))
  

 Relation analysis of STFL 
===========================

Following new types were introduced:
  !(e)(→)in0 	(derived from e)
  (e)(→)in0 	(derived from e)
  !(e)(⊢)in1 	(derived from e)
  (e)(⊢)in1 	(derived from e)
  !(eL)(→)in0 	(derived from eL)
  (eL)(→)in0 	(derived from eL)
  !(eL)(⊢)in1 	(derived from eL)
  (eL)(⊢)in1 	(derived from eL)
  !(typeL)(==)in0 	(derived from typeL)
  (typeL)(==)in0 	(derived from typeL)
  !(typeL)(==)in1 	(derived from typeL)
  (typeL)(==)in1 	(derived from typeL)
  (value)(⊢)in1 	(derived from value)
  (value)(✓)in0 	(derived from value)

Following types were ommitted, as they turned out to coincide with some other type:
  ((e)(→)in0)(→*)in0 	== (e)(→)in0
  ((e)(⊢)in1)(::)in0 	== (e)(⊢)in1
  ((e)(✓)in0)(→*)in0 	== (e)(✓)in0
  ((type)(==)in0)(==)in0 	== (type)(==)in0
  ((type)(==)in1)(==)in1 	== (type)(==)in1
  ((typingEnvironment)(⊢)in0)(⊢)in0 	== (typingEnvironment)(⊢)in0
  (bool)(⊢)in1 	== bool
  (bool)(✓)in0 	== bool
  (e)(::)in0 	== (eL)(::)in0
  (e)(→*)in0 	== (eL)(→*)in0
  (e)(✓)in0 	== (eL)(✓)in0
  (eL)(::)in0 	== (value)(::)in0
  (eL)(→*)in0 	== (value)(→*)in0
  (eL)(✓)in0 	== (value)(✓)in0
  (number)(⊢)in1 	== number
  (number)(✓)in0 	== number
  (type)(==)in0 	== type
  (type)(==)in1 	== type
  (typingEnvironment)(⊢)in0 	== typingEnvironment

Following types were omitted, as they turned out to be empty. They might cause 'dissapearing' choices in other rules:
  !(value)(⊢)in1
  !(value)(✓)in0
  (value)(::)in0
  (value)(→)in0
  (value)(→*)in0
  (bool)(::)in0
  (bool)(→)in0
  (bool)(→*)in0
  (number)(::)in0
  (number)(→)in0
  (number)(→*)in0
  (var)(::)in0
  (var)(→)in0
  (var)(→*)in0
  (var)(⊢)in1
  (var)(✓)in0

!(e)(→)in0 has following subtypes:  !(eL)(→)in0
!(e)(⊢)in1 has following subtypes:  !(eL)(⊢)in1
!(eL)(→)in0 has following subtypes:  value
  var
!(eL)(⊢)in1 has following subtypes:  var
(e)(→)in0 has following subtypes:  (eL)(→)in0
(e)(⊢)in1 has following subtypes:  (eL)(⊢)in1
(eL)(⊢)in1 has following subtypes:  (value)(⊢)in1
(value)(⊢)in1 has following subtypes:  bool
  number
(value)(✓)in0 has following subtypes:  bool
  number
e has following subtypes:  !(e)(→)in0
  !(e)(⊢)in1
  (e)(→)in0
  (e)(⊢)in1
  eL
eL has following subtypes:  !(eL)(→)in0
  !(eL)(⊢)in1
  (eL)(→)in0
  (eL)(⊢)in1
  value
  var
type has following subtypes:  typeL
typeL has following subtypes:  !(typeL)(==)in0
  !(typeL)(==)in1
  (typeL)(==)in0
  (typeL)(==)in1
value has following subtypes:  (value)(⊢)in1
  (value)(✓)in0
  bool
  number


 Resulting Syntax 
------------------

bool             ::= "True"
                 | "False"
e                ::= eL "+" e
                 | eL "::" type
                 | eL e
                 | eL
eL               ::= value
                 | var
                 | "(" "\\" var ":" type "." e ")"
                 | "If" e "Then" e "Else" e
                 | "(" e ")"
number           ::= Number
type             ::= typeL "->" type
                 | typeL
typeL            ::= "Int"
                 | "Bool"
                 | "(" type ")"
typing           ::= var ":" type
typingEnvironment::= typing "," typingEnvironment
                 | "{}"
value            ::= bool
                 | number
var              ::= Identifier


# Run --irasvg PATH.svg to generate a nice svg about the subtyping relationsships
