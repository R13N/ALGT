Test/STFL.language --ira

Warning:
  While checking the totality of function "cod":
    Following calls will fall through:
      cod("Bool")
      cod("Int")
  While checking the totality of function "dom":
    Following calls will fall through:
      dom("Bool")
      dom("Int")
  While checking the totality of function "eval":
    Following calls will fall through:
      eval(("(" "\\" var ":" type "." e ")"))
  
  While checking liveability of every clause in function "subs":
    subs(x, y, "(" e ")")    = "(" subs(x, y, e) ")" will never match anything, as the possible arguments are already consumed
  

 Relation analysis of STFL 
===========================

Following new types were introduced:
  !(e)(→)in0 	(derived from e)
  (e)(→)in0 	(derived from e)
  !(e)(⊢)in1 	(derived from e)
  (e)(⊢)in1 	(derived from e)
  !(eL)(→)in0 	(derived from eL)
  (eL)(→)in0 	(derived from eL)
  !(eL)(⊢)in1 	(derived from eL)
  (eL)(⊢)in1 	(derived from eL)
  !(typeL)(==)in0 	(derived from typeL)
  (typeL)(==)in0 	(derived from typeL)
  !(typeL)(==)in1 	(derived from typeL)
  (typeL)(==)in1 	(derived from typeL)
  !(value)(⊢)in1 	(derived from value)
  (value)(⊢)in1 	(derived from value)
  !(value)(✓)in0 	(derived from value)
  (value)(✓)in0 	(derived from value)

Following types were ommitted, as they turned out to coincide with some other type:
  ((e)(→)in0)(→*)in0 	== (e)(→)in0
  ((e)(⊢)in1)(::)in0 	== (e)(⊢)in1
  ((e)(✓)in0)(→*)in0 	== (e)(✓)in0
  ((type)(==)in0)(==)in0 	== (type)(==)in0
  ((type)(==)in1)(==)in1 	== (type)(==)in1
  ((typingEnvironment)(⊢)in0)(⊢)in0 	== (typingEnvironment)(⊢)in0
  (bool)(⊢)in1 	== bool
  (bool)(✓)in0 	== bool
  (e)(::)in0 	== (eL)(::)in0
  (e)(→*)in0 	== (eL)(→*)in0
  (e)(✓)in0 	== (eL)(✓)in0
  (eL)(::)in0 	== (value)(::)in0
  (eL)(→*)in0 	== (value)(→*)in0
  (eL)(✓)in0 	== (value)(✓)in0
  (number)(⊢)in1 	== number
  (number)(✓)in0 	== number
  (type)(==)in0 	== type
  (type)(==)in1 	== type
  (typingEnvironment)(⊢)in0 	== typingEnvironment

Following types were omitted, as they turned out to be empty. They might cause 'dissapearing' choices in other rules:
  (value)(::)in0
  (value)(→)in0
  (value)(→*)in0
  (bool)(::)in0
  (bool)(→)in0
  (bool)(→*)in0
  (number)(::)in0
  (number)(→)in0
  (number)(→*)in0
  (var)(::)in0
  (var)(→)in0
  (var)(→*)in0
  (var)(⊢)in1
  (var)(✓)in0

!(e)(→)in0 has following subtypes:  ɛ
!(e)(⊢)in1 has following subtypes:  ɛ
!(eL)(→)in0 has following subtypes:  value
  var
!(eL)(⊢)in1 has following subtypes:  var
!(typeL)(==)in0 has following subtypes:  ɛ
!(typeL)(==)in1 has following subtypes:  ɛ
!(value)(⊢)in1 has following subtypes:  ɛ
!(value)(✓)in0 has following subtypes:  ɛ
(e)(→)in0 has following subtypes:  (eL)(→)in0
(e)(⊢)in1 has following subtypes:  (eL)(⊢)in1
(eL)(→)in0 has following subtypes:  ɛ
(eL)(⊢)in1 has following subtypes:  (value)(⊢)in1
(typeL)(==)in0 has following subtypes:  ɛ
(typeL)(==)in1 has following subtypes:  ɛ
(value)(⊢)in1 has following subtypes:  bool
  number
(value)(✓)in0 has following subtypes:  bool
  number
bool has following subtypes:  ɛ
e has following subtypes:  !(e)(→)in0
  !(e)(⊢)in1
  (e)(→)in0
  (e)(⊢)in1
  eL
eL has following subtypes:  !(eL)(→)in0
  !(eL)(⊢)in1
  (eL)(→)in0
  (eL)(⊢)in1
  value
  var
number has following subtypes:  ɛ
type has following subtypes:  typeL
typeL has following subtypes:  !(typeL)(==)in0
  !(typeL)(==)in1
  (typeL)(==)in0
  (typeL)(==)in1
  ɛ
typing has following subtypes:  ɛ
typingEnvironment has following subtypes:  ɛ
value has following subtypes:  !(value)(⊢)in1
  !(value)(✓)in0
  (value)(⊢)in1
  (value)(✓)in0
  bool
  number
var has following subtypes:  ɛ
ɛ has following subtypes:

 Resulting Syntax 
------------------

!(e)(→)in0       ::= bool "+" !(e)(→)in0
                 | var "+" !(e)(→)in0
                 | "(" "\\" var ":" type "." e ")" "+" !(e)(→)in0
                 | "If" e "Then" e "Else" e "+" !(e)(→)in0
                 | "(" e ")" "+" !(e)(→)in0
                 | !(eL)(→)in0 "+" eL "+" e
                 | !(eL)(→)in0 "+" eL "::" type
                 | !(eL)(→)in0 "+" eL e
                 | !(eL)(→)in0 "+" bool
                 | !(eL)(→)in0 "+" var
                 | !(eL)(→)in0 "+" "(" "\\" var ":" type "." e ")"
                 | !(eL)(→)in0 "+" "If" e "Then" e "Else" e
                 | !(eL)(→)in0 "+" "(" e ")"
                 | !(eL)(→)in0 "::" type
                 | !(eL)(→)in0 !(e)(→)in0
!(e)(⊢)in1       ::= !(eL)(⊢)in1 "+" e
                 | eL "+" !(e)(⊢)in1
                 | !(eL)(⊢)in1 "::" type
                 | !(eL)(⊢)in1 e
                 | eL !(e)(⊢)in1
!(eL)(→)in0      ::= value
                 | var
                 | "(" "\\" var ":" type "." !(e)(→)in0 ")"
                 | "If" eL "+" e "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" eL "::" type "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" eL e "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" number "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" var "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" "(" "\\" var ":" type "." e ")" "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" "If" e "Then" e "Else" e "Then" !(e)(→)in0 "Else" !(e)(→)in0
                 | "If" "(" e ")" "Then" !(e)(→)in0 "Else" !(e)(→)in0
!(eL)(⊢)in1      ::= var
                 | "(" "\\" var ":" type "." !(e)(⊢)in1 ")"
                 | "If" !(e)(⊢)in1 "Then" e "Else" e
                 | "If" e "Then" !(e)(⊢)in1 "Else" e
                 | "If" e "Then" e "Else" !(e)(⊢)in1
                 | "(" !(e)(⊢)in1 ")"
!(typeL)(==)in0  ::= "Int"
                 | "Bool"
!(typeL)(==)in1  ::= "Int"
                 | "Bool"
!(value)(⊢)in1   ::= < no bnfs declared >
!(value)(✓)in0   ::= < no bnfs declared >
(e)(→)in0        ::= (eL)(→)in0
                 | (eL)(→)in0 "+" e
                 | eL "+" (e)(→)in0
                 | number "+" number
                 | (eL)(→)in0 "::" type
                 | bool "::" "Bool"
                 | eL "::" "(" type ")"
                 | number "::" "Int"
                 | (eL)(→)in0 e
                 | eL (e)(→)in0
                 | "(" "\\" var ":" type "." e ")" e
(e)(⊢)in1        ::= (eL)(⊢)in1
                 | (eL)(⊢)in1 "+" (e)(⊢)in1
                 | (eL)(⊢)in1 "::" type
                 | (eL)(⊢)in1 (e)(⊢)in1
(eL)(→)in0       ::= "(" "\\" var ":" type "." (e)(→)in0 ")"
                 | "If" (e)(→)in0 "Then" e "Else" e
                 | "If" bool "Then" e "Else" e
                 | "If" e "Then" (e)(→)in0 "Else" e
                 | "If" e "Then" e "Else" (e)(→)in0
                 | "(" e ")"
(eL)(⊢)in1       ::= (value)(⊢)in1
                 | "(" "\\" var ":" type "." (e)(⊢)in1 ")"
                 | "If" (e)(⊢)in1 "Then" (e)(⊢)in1 "Else" (e)(⊢)in1
                 | "(" (e)(⊢)in1 ")"
(typeL)(==)in0   ::= "(" type ")"
(typeL)(==)in1   ::= "(" type ")"
(value)(⊢)in1    ::= bool
                 | number
(value)(✓)in0    ::= bool
                 | number
bool             ::= "True"
                 | "False"
e                ::= eL "+" e
                 | eL "::" type
                 | eL e
                 | eL
eL               ::= value
                 | var
                 | "(" "\\" var ":" type "." e ")"
                 | "If" e "Then" e "Else" e
                 | "(" e ")"
number           ::= Number
type             ::= typeL "->" type
                 | typeL
typeL            ::= "Int"
                 | "Bool"
                 | "(" type ")"
typing           ::= var ":" type
typingEnvironment::= typing "," typingEnvironment
                 | "{}"
value            ::= bool
                 | number
var              ::= Identifier


# Run --irasvg PATH.svg to generate a nice svg about the subtyping relationsships
