
 Relations and Rules: building the evaluator
---------------------------------------------

While we could build an function which evaluates our programming languages, language designers love _natural deduction_ more. Don't worry if you never heard about that before, we'll explain it right away!

### Declaring relation "evaluation"

First, we declare a new section inside our _STFL.language_, with a relation declaration inside:

$$STFL.language![60..63]!file

Let us break this line down.

The first part, `(→)`, says that we declare a relation with name `→`. Except from some builtin symbols, you can use whatever string you want, including unicode[^unicodeArrow]. If you don't want to use the unicode-arrow for this tutorial, you can replace `→` by `->`.

The second part, `: expr (in), expr (out)` states that this is a relation between two `expr`. As example, `2 + 3` , `5` will be in `(→)` or written more conventionally `2 + 3 →` `5`.

What about the `(in)` and `(out)` parts? These are to help the computer. Given `2 + 3`, it's pretty easy for the computer to calculate `5`. Given `5`, the computer can't magically deduce that this was computed by calculating `2 + 3`, especially because an infinite amount of possible calculations might lead to the result `5`.
We call this the *mode* of the argument.

The last part, `Pronounced as "evaluation"` defines a name for the relation. It's just an extra, to help users of your language to know what a relation is supposed to do or to help them searching it on a search engine.

Note that the goal of `→` is to make a small, fundamental step - just one addition or simplification, e.g. `1 + 2 + 3` `→` `1 + 5`. We'll design another relation later on which will give us the end result immediatly, giving us `6`.

[^unicodeArrow]: to enter an unicode character on a linux machine, type `Left-Ctrl + Shift + U`, release, and type the hexcode of the desired character, e.g. `2192` to get the right-arrow. On windows, hold down `Alt` and type `+ 2192`.

### Defining relation "evaluation"


#### Simple deduction rules: If

Defining relations works with one or more rules.

We start with a simple one:


$$STFLEvalIfCond.language![98..102]!file



How should you read this rule? The part under the line says that this is part of the relation; in other words; `"If" "True" "Then" e1 "Else" e2` will evaluate to `e1`. 
This is equivalent to writing the function `eval("If" "True" "Then" e1 "Else" e2) = e1`.

The part on the right of the line `[EvalIfTrue]` gives the name of the rule. You can put there pretty much everything you want.

Analogously, you can add a rule for `If False`:

	 
$$STFLEvalIfCond.language![102..106]!file

This is already enough to run our third example. To run a relation, specify `-r <name-of-relation>`, thus `./ALGT STFL.language examples.stfl expr -l -r →`:


$$($$STFL.language![0..90],[104..112] $$examples.stfl!3 expr -l -r → --nc)

#### Deduction rules with predicates: plus

How do we add numbers? We can add a deduction rule just as well for this:

$$STFL.language![99..101]!file

First, take a look at the bottom line. The left part is straightforward; we match a parsetree with form `n1 + n2`. But what is this `!plus(n1, n2)`. It's a function call with arguments `n1` and `n2`. The exclamation mark `!` indicates that this is a builtin function.

In other words, this rule indicates that `1 + 2` should be evaluated with `!plus(1,2)`, giving three.

There is a catch, though. `!plus` has type `Number -> Number -> Number` (recall, this means that plus takes two `Numbers` and gives us a `Number` in return).
We can't pass in other types, or it would fail. We thus have to check that we get correct input for this rule. To do this, we have those predicates on top: `n1:Number` (read this as _`n1` is of syntactic form `Number`_) and `n2:Number`.

Let give this a run!

$$($$STFL.language![0..90],[99..112] $$examples.stfl!6,7 expr -l -r → --nc)

We can see that our simple example, `20 + 22` neatly gives us the answer[^tolife]. The other example, `1 + 2 + 3` however, fails.
Note that it gives a detailed overview of what rules it attempted to apply and why those rules failed.


[^tolife]: Luckily, your computer didn't have to run for 10 million years. And it conveniently gave the question too, so that we wouldn't forget it.

#### If with complicated conditions


But what with our fourth example, `$$examples.stfl!4`? The condition itself as an `If`-expression as well.

Herefore we introduce a more complicated rule:

$$STFLEvalIfCond.language![92..97]!file


The part above the line should be read as a condition. It states that, whenever `cond0` evaluates to `cond1`, then we can evaluate the bigger expression.

#### Evaluation contexts for congruence rules

However, there is a way to write this even shorter:

$$STFL.language![92..97]!file


The part `expr[expr0]` will search, within the expression we want to evaluate, a nested expression that satisfies the conditions. In other words, it will search in the parsetree (`If (If True Then False Else False) Then True Else False`) a part that can be evaluated (e.g. `If True Then False Else False`).

The evaluated expression will then be put back in the original, bigger parsetree at the same location.

Make sure to name the nested expr `expr0`, thus _syntactic-form-name_ followed by a number. That's how the tool figures out what kind of parsetree to search for.

$$($$STFL.language![0..112] $$examples.stfl!4 expr -l -r → --nc)


As a bonus, it'll also solve our `1 + 2 + 3`! 

$$($$STFL.language![0..112] $$examples.stfl!7 expr -l -r → --nc)


These proofs are getting a bit harder to read, but always start from the bottom if you get lost. 

It basically states that `1 + (2 + 3)` makes a step to `1 + 5`, because  of rule `EvalCtx`; this rule could be used because `2 + 3` evaluates to `5`.

The proof for that part of the relation is given more on top, by rule `EvalPlus`, which could be invoked because both `2` and `3` are `Number`s.

#### Application

As last, we'd like to apply functions, such as `(\\x : Int . x + 1) 41`.

Our intution is that, given something as `(\\x : someType . someExpr) someArg`, we want to evaluate this to `someExpr`, where we replace every `x` in `someExpr`. However, a builtin function does exactly that: `!subs`. This gives us the following rule:

$$STFL.language!114,115!file


$$($$STFL.language![0..115] $$examples.stfl!8 expr -l -r → --nc)


### Evaluation-relation: recap

Our evaluation rule is defined as:

$$STFL.language![59..63],[86..88],[92..116]!file

### Is canonical

It is usefull to known when an expression is _canonical_, thus is fully evaluated. This can be simply stated by a relation taking just one argument and _giving no output_[^itsASet]. It would contain exactly the `Number`s, `True` and `False`.

First, the declaration in the `Relations`-section:

$$STFL.language!65!file


And the implementation:

$$STFL.language![120..127]!file

[^itsASet]: Mathematicians would call this a _set_.


### Bigstep


Of course, when we input `1 + 2 + 3`, we would like te get `6`, and not `1 + 5`. For this, we can define a second relation, 

First, let us declare this:

$$STFL.language!64!file

First, the basecase. If something is canonical, we are done and just return that unchanged. 
We express this as following:

$$STFL.language![132..134]!file

What if we are not done? That means that we can make a single step, `e0 → e1` and that we calculate this `e1` to its canonical from `e2` with the relation itself!

$$STFL.language![136..138]!file

So, we finally did it! Time to see our examples in all their glory!

$$($$STFL.language![0..140] $$examples.stfl!1 expr -l -r →* --nc)
$$($$STFL.language![0..140] $$examples.stfl!2 expr -l -r →* --nc)
$$($$STFL.language![0..140] $$examples.stfl!3 expr -l -r →*  --short-proofs 4 --nc)

$$($$STFL.language![0..140] $$examples.stfl!5 expr -l -r →* --nc)
$$($$STFL.language![0..140] $$examples.stfl!6 expr -l -r →* --short-proofs 4 --nc)
$$($$STFL.language![0..140] $$examples.stfl!7 expr -l -r →* --short-proofs 4 --nc)
$$($$STFL.language![0..140] $$examples.stfl!8 expr -l -r →* --short-proofs 1 --nc)


Building the typechecker
------------------------

Now that we have the evaluator and some experience, we can slay the next dragon: the typechecker!

For those unfamiliar, the typechecker looks at the expression and determines the type of it and halts on inconsistencies, such as `1 + True` or `If True Then 0 Else False`, ...

we will build a single rule for each syntactic choice of `expr`; thu a rule for:

- The constants `True` and `False`
- The constant `Number`s
- Typing plus
- Typing `If ... Then ... Else ...`
- Typing lambda's `(\\x : T . e)`
- Typing variables `x`
- Typing application

### The typing environment

Before where start, how should we type a variable, such as `x`? Of course, this depends on the environment. In the lambda `(\\x : Int . x)`, `x` should be typed as a `Int`, while in the lambda `(\\ x : Bool . x)`, this `x` clearly is a `Bool`. 

We could type the inner expressions by substituting a simple default value in the expression, and then typing it. This however, doesn't scale to more advanced languages.

The other, more general solution is keeping track of the type of each variable. 
We declare a simple list to keep track of the types in the `Syntax Section`:

$$STFL.language!27,28!file

The `typing` represents a data entry, whereas the `typingEnvironment` can contain zero or more of these data entries, thus keeping track of the variable types. 

The typing relation will often be denoted with a uppercase gamma, `Γ` (U+0393).

### The typing relation

We're all set now! What should our typing relation look like? First, we'll want to take a `typingRelation` as input, together with an `expr`. This should be enough to calculate the `type` of the expression.

In other words, the type of the relation is `typingRelation (in), expr (in), type (out)`. In the acadical world, this is often given the symbol `⊢` [^entailsSymbol], pronounced `entails` or `out of this environment follows this typing`. 

[^entailsSymbol]: Type `Ctrl+Shift+U 22a2` on linux to input this character. On Windows, hold down `Alt` and type `+ 22a2`.

So, our declaration becomes:

$$STFL.language!67!file

### Typing constants `True` and `False`

It's pretty easy to type constants, such as `42` and `True`.

Let us start with typing the constant `True`. 

$$STFL.language![150..152]!file

If this look a bit magical: we take the typing environment as input, left of the `⊢`, pattern match on a literl `True` and return the known type `Bool`.

We can do the same for `False`:

$$STFL.language![154..156]!file

### Typing constant `Number`s

Our next challenge is giving a type to `Int`s. Make a single rule for each number is a bit hard, given that there are infinite many of them...

However, we can simply fix this by adding a predicate, checking that our input is a number:

$$STFL.language![159..161]!file

Remember that our predicates are written above the line.

### Typing against an empty environment

Let's try to run our typing relation, with `./ALGT STFL.language expr -l -r ⊢`

$$($$STFL.language $$examples.stfl!1 expr -l -r ⊢ --nc)

Well, that didn't work. The tool expects two arguments; but only one is provided...

To solve this, we declare yet another relation, in which we type an expression against an empty environment:

$$STFL.language![159..161]!file

Retrying with the new relation (`./ALGT STFL.language $$examples.stfl expr -l -r ::`) gives us:

$$($$STFL.language $$examples.stfl![1..2] expr -l -r :: --nc)
$$($$STFL.language $$examples.stfl!3 expr -l -r :: --nc --short-proofs 2)



### Typing plus

Another expression we'll want to type are additions. 

Of course, this will always return an `Int`, but there is more. `True + False` is not valid, whereas `1 + 1` can be typed. In other words, we have to check that the arguments to `+` are both numbers.

We could thus type plus as following:

         n1:Number n2:Number
        ------------------------------				[TPlus]
         Γ ⊢ n1 "+" n2, "Int"

This works for `1 + 2`, but not for `1 + (2 + 3)`, as ` (2 + 3)` is _not_ a syntactic form that is a literal `Number`. It can be typed as `Int` though, so we can generalize our predicates by using the typing relationship recursively:

$$STFL.language![174..176]!file

Looks good! Time to give this a try:

$$($$STFL.language $$examples.stfl!7 expr -l -r :: --nc --short-proofs 4)

### Typing `If`

It is pretty straightforward that the condition of our `If` should be `Bool`, which already gives a draft of the rule:

         Γ ⊢ cond, "Bool"
        ----------------------------------------------------- [TIf]
         Γ ⊢ "If" cond "Then" e1 "Else" e2,  ???

We also want to make sure that both `e1` and `e2` are correctly typed, so we recursively typecheck them:

         Γ ⊢ cond, "Bool"      Γ ⊢ e1, T1     Γ ⊢ e2, T2
        ----------------------------------------------------- [TIf]
         Γ ⊢ "If" cond "Then" e1 "Else" e2,  ???




But what type should we return? The type of `e1` or `e2`?

Consider expression `If True Then 0 Else False`. Evaluating this for one step, would yield `0`. However, expression `If False Then 0 Else False` would yield `False`. In other words, depending on the runtime value of the condition, we might get a different type.

That's not behaviour we want. The types of `e1` and `e2` should be the same to function correctly. We add a predicate to check this:

         Γ ⊢ cond, "Bool"      Γ ⊢ e1, T1     Γ ⊢ e2, T2     T1 = T2
        ------------------------------------------------------------- [TIf]
         Γ ⊢ "If" cond "Then" e1 "Else" e2,  ???

Now we can also return a type; as `T1` and `T2` are the same, we just pick one:

$$STFL.language![179..181]!file


All done! Time to give it a try:

$$($$STFL.language $$examples.stfl!3 expr -l -r :: --nc --short-proofs 2)

### Typing lambda's

Typing lambda's is a bit complicated. Remember that a lambda such as  `(\\x : T . e)` means that, _given `x` of type `T` as input argument, it gives back expression `e` with `x` replaced_.

 This gives us quite some clues about what to do.

Let's start with the skeleton of the rule:

         ???
        ---------------------------------------------------- [TLambda]
         Γ ⊢ "(" "\\" x ":" T1 "." e ")", ???


Of course, we'll want to type `e` jus as well. Not only to check wether it is correct, but also because we'll need it's type later on:

         Γ ⊢ e, T1
        ---------------------------------------------------- [TLambda]
         Γ ⊢ "(" "\\" x ":" T1 "." e ")", ???

This is close to what we want, but there is a catch though: in the expression `e`, we know that `x` has the type `T1`. We should pass this knowledge to the typing of `e`, by adding it to the typing environment `Γ`:

         (x ":" T1) "," Γ ⊢ e, T2
        ---------------------------------------------------- [TLambda]
         Γ ⊢ "(" "\\" x ":" T1 "." e ")", ???

So far, so good! The only question remaining is what type we should return. We know we have input of type `T1` and output of type `T2`. Thats where our `->` comes into play: the entire lambda has type `T1 -> T2`!

There is a little technicality into play here though: `T1` might be some complicated type, such as `Int -> Bool` - meaning we expect a _function_ as input argument. If we would write `Int -> Bool -> T2`, that would be read as funcion taking _two_ arguments: first a `Int`, followed by a `Bool`. Not quite the same thus. 

The fix for this is simple: add parentheses. The type of a lambda is  `(T1) -> T2`.

Typing this out as rule yields:

$$STFL.language![185..187]!file

Note that an extra pair of parentheses was added; one pair is between double quotes, denoting that this should be added in the parse tree; the other pair just groups them together to help the tool build the parsetree.

### Typing variables

Before we can see typing of lambda's live, we need to take another hurdle: typing variables.

You'll probably think it'll be a lot of work to design the searching behaviour, but luckily, there is a special construction builtin that does exactly that. Remember the evaluation context? We can put this to work here too:

$$STFL.language![169..171]!file

Quite succint! If you're a bit puzzled about it's workins, we stated to ALGT that it should search a typing of `x`, where `x` is exactly the name of the variable we want to type.

At this point, we can finally type a single lambda:

$$($$STFL.language $$examplelambda.stfl expr -l -r :: --nc)

### Typing application

The typechecker is nearly complete, only a single syntactic form can't be typed yet: application of the form `function argument`.

How can we tackle this problem? For starters, we'll have to type the `function` and `argument`

         Γ ⊢ func, TFunc     Γ ⊢ arg, TArg
        --------------------------------------------------- [TApp]
         Γ ⊢ func arg, ???

A function has a determined input argument, also known as the _domain_ of the function. To be well typed, the domain should match the type of the argument exactly. But how can we get this argument?

Luckily, we created a function earlier on that calculates exactly that! We can simply use that and check that it's result equals `TArg`:

         Γ ⊢ func, TFunc     Γ ⊢ arg, TArg     domain(TFunc) = TArg
        --------------------------------------------------- [TApp]
         Γ ⊢ func arg, ???

Nearly done! Only question left is what type we should return.

This is pretty straighforward too, as we earlier made the function `codomain` which exactly calculates the return type of `TFunc`

$$STFL.language![191..193]!file

All finished now, except for trying of course:

$$($$STFL.language $$examples.stfl!8 expr -l -r :: --nc)

Evaluator and typechecker: recap
---------------------------------------------------

Our declared relations are:

$$STFL.language![60..71]!file

The definitiion of those relations are:


$$STFL.language![87..216]!file

Running the relation `::` on all our examples with flags `./ALGT STFL.language $$examples.stfl expr -l -r :: --no-check` gives:

$$($$STFL.language $$examples.stfl![1..3],[5..8] expr -l -r :: --nc --short-proofs 2)
