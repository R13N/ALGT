
 Syntax
========

# Types
typeL	::= "Int" | "Bool" | "(" type ")"
type	::=  typeL "->" type | typeL


# builtins values
var	::= Identifier
number	::= Number
bool	::= "True" | "False"
value	::= number | bool
e	::= eL "+" e | eL "::" type | eL e | eL
eL	::= value | var | "(" "\\" var ":" type "." eL ")" | "If" e "Then" e "Else" e | "(" e ")"


# typing			::= var ":" type
# typingEnvironment	::= typing "," typingEnvironment | "{}"

 Functions
===========

dom 		: type -> type
dom("(" T ")")	= "(" dom(T) ")"
dom(T1 "->" T2) = T1

cod 		: type -> type
cod("(" T ")")	= "(" cod(T) ")"
cod(T1 "->" T2) = T2


equality	: type -> type -> type
equality(T , T)	= T


# deduces a new name for the variable in an lambda abstraction
rename		: var -> var -> type -> e -> e
rename(x, newVar, type, body)
		= "(" "\\" newVar ":" type "." subs(x, newVar, body ) ")"

# replaces variable x by y in entire expression
subs						: var -> e -> e -> e
subs(x, y, x)					= y
subs(x, y, "(" "\\" x ":" t "." rest ")" )		= subs(x, y, rename(x, !newvar(x, rest), t, rest) )
subs(x, y, "(" "\\" z ":" t "." rest ")" )		= "(" "\\" z ":" t "." subs(x,y,rest) ")"
subs(x, y, "If" cond "Then" e1 "Else" e2)	= "If" subs(x, y, cond) "Then" subs(x, y, e1) "Else" subs(x, y, e2)
subs(x, y, e1 "+" e2)				= subs(x, y, e1) "+" subs(x, y, e2)
subs(x, y, e "::" type)				= subs(x, y, e) "::" type
subs(x, y, f arg)				= subs(x, y, f) subs(x, y, arg) 
subs(x, y, z)					= z



eval			: e -> e
eval( (v : value) )	= v
eval(("(" "\\" x ":" t "." e ")") arg)
			= eval(subs(x, arg, e))
eval("If" "True" "Then" e1 "Else" e2)
			= eval(e1)
eval("If" "False" "Then" e1 "Else" e2)
			= eval(e2)
eval("If" c "Then" e1 "Else" e2)
			= eval("If" eval(c) "Then" e1 "Else" e2)
eval("(" e ")")		= eval(e)
eval(e1 "+" e2)		= plus(eval(e1), eval(e2))
eval(e "::" t)		= eval(e)



# wrappers for builtin functions, as we can't type within a builtin
plus		: number -> e -> number
plus(e1, e2)	= !plus((e1:number), e2)


