module TypeSystem where

{-
This module defines the AST for TypeSystems
-}

import Utils

import Data.List (intersperse, intercalate)

import Data.Map (Map)
import qualified Data.Map as M
import Data.Maybe
import Data.List

import Control.Arrow ((&&&))

------------------------ Syntax -------------------------


{- Syntax is described in a Backus-Naur format, a simple naive parser is constructed from it. -}

data BNFAST 	= Literal String	-- Literally parse 'String'
		| Identifier		-- Parse an identifier
		| Number		-- Parse a number
		| BNFRuleCall Name	-- Parse the rule with the given name
		| Seq [BNFAST]		-- Sequence of parts
	deriving (Show, Eq)


fromSingle	:: BNFAST -> Maybe BNFAST
fromSingle (Seq [bnf])	= Just bnf
fromSingle (Seq _)	= Nothing
fromSingle bnf		= Just bnf


fromRuleCall	:: BNFAST -> Maybe Name
fromRuleCall (BNFRuleCall nm)	= Just nm
fromRuleCall _			= Nothing

{-Represents a syntax: the name of the rule + possible parseways -}
type BNFRules	= Map TypeName [BNFAST]

bnfNames	:: BNFRules -> [Name]
bnfNames r	=  M.keys r & sortOn length & reverse


{-
Consider following BNF:
x ::= ... | y | ...
y ::= ...

This means that every 'y' also (and always) is an 'x'

alwaysIsA searches these relations:

alwaysIsA rules 'y' 'x'	--> True

-}
alwaysIsA	:: BNFRules -> Name -> Name -> Bool
alwaysIsA rules sub super
 | super == ""	= True	-- The empty string is used in dynamic cases, thus are equivalent to everything
 | sub == super	= True
 | super `M.notMember` rules
	= error $ "Unknwown super name: "++show super
 | otherwise	-- super-rule should contain a single occurence, sub or another rule
	= let	superR	= (rules M.! super) |> fromSingle & catMaybes
		-- this single element should be a BNFRuleCall
		superR'	= superR |> fromRuleCall & catMaybes
		-- either sub is an element from superR', or it has a rule which is a super for sub
		-- we don't have to worry about loops; as that would block parsing
		in sub `elem` superR' || or (superR' |> alwaysIsA rules sub)
				
-- Either X is a Y, or Y is a X
equivalent	:: BNFRules -> Name -> Name -> Bool
equivalent r x y
		= alwaysIsA r x y || alwaysIsA r y x

------------------------ functions -------------------------

-- functions do transform syntax trees (by rewrite rules) and are often used in typechecking and evaluation


type TypeName	= Name
type Type	= [TypeName]	


-- A Expression is always based on a corresponding syntacic rule. It can be both for deconstructing a parsetree or constructing one (depending wether it is used as a pattern or not)
type Builtin	= Bool
type MInfo	= (TypeName, Int)
data Expression
	= MVar MInfo Name
	| MIdentifier MInfo Name	-- identifier, generated by 'Identifier'
	| MLiteral MInfo String
	| MInt MInfo Int
	| MSeq MInfo [Expression]	
	| MCall TypeName Name Builtin [Expression]	-- not allowed in pattern matching
	| MAscription TypeName Expression -- checks wether the expression is built by this smaller rule.
	deriving (Ord, Eq)

isMInt	:: Expression -> Bool
isMInt (MInt _ _)	= True
isMInt _	= False

usedIdentifiers	:: Expression -> [Name]
usedIdentifiers (MIdentifier _ nm)	= [nm]
usedIdentifiers (MSeq _ exprs)		= exprs >>= usedIdentifiers
usedIdentifiers (MCall _ _ _ exprs)	= exprs >>= usedIdentifiers
usedIdentifiers (MAscription _ expr)	= usedIdentifiers expr
usedIdentifiers	_			= []

-- generates an MVar, with a name that does not occurr in the given expression
unusedIdentifier	:: Expression -> (Maybe Name) -> TypeName -> Expression
unusedIdentifier noOverlap baseName productionType 
	= let	name	= fromMaybe "x" baseName
		alreadyUsed = name: usedIdentifiers noOverlap
		varName	= [0..] |> show |> (name++) & filter (`notElem` alreadyUsed) & head
		in
		MIdentifier (productionType, -2) varName

typeOf	:: Expression -> TypeName
typeOf (MVar (tp, _) _)	= tp
typeOf (MLiteral (tp, _) _)
			= tp
typeOf (MInt (tp, _) _) = tp
typeOf (MSeq (tp, _) _)	= tp
typeOf (MCall tp _ _ _)	= tp
typeOf (MAscription tp _)	= tp

data Clause	= MClause {mecPatterns :: [Expression], mecExpr :: Expression}
	deriving (Ord, Eq)


data Function	= MFunction Type [Clause]
	deriving (Ord, Eq)

typeOfF			:: Function -> Type
typeOfF (MFunction t _)	= t


type Functions	= Map Name Function




----------------------- Proof Rules ------------------------


type Symbol		= Name
data Mode		= In | Out
	deriving (Show, Ord, Eq)
data Relation		= Relation {relSymbol :: Symbol, relTypesModes :: [(TypeName, Mode)], relPronounce :: (Maybe String) }
	deriving (Ord, Eq)

relType		:: Relation -> [TypeName]
relType r	= r & relTypesModes |> fst

relModes	:: Relation -> [Mode]
relModes r	= r & relTypesModes |> snd

filterMode	:: Mode -> Relation -> [a] -> [a]
filterMode mode rel as
	= zip as (relModes rel) & filter ((==) mode . snd) |> fst


data Conclusion		= RelationMet 	{ conclusionRel 	:: Relation
					, conclusionArgs 	:: [Expression]
					}
	deriving (Ord, Eq)



data Predicate		= TermIsA Expression TypeName
			| Needed Conclusion
	deriving (Ord, Eq)

data Rule		= Rule 	{ ruleName 	:: Name
				, rulePreds 	:: [Predicate]
				, ruleConcl	:: Conclusion
				} deriving (Ord, Eq)


data Proof	= Proof { proofConcl	:: Conclusion
			, prover	:: Rule
			, proofPreds	:: [Proof]	-- predicates for the rule
			}
		| ProofIsA Expression TypeName
		 deriving (Ord, Eq)

isProof (Proof {})	= True
isProof _		= False

depth	:: Proof -> Int
depth (ProofIsA _ _)	= 1
depth proof
	= if null (proofPreds proof) then 1
		else proofPreds proof |> depth & maximum & (+1)

weight	:: Proof -> Int
weight (ProofIsA _ _)	= 1
weight proof	= 1 + (proof & proofPreds |> weight & sum)


------------------------ Typesystemfile ------------------------

{-Represents a full typesystem file-}
data TypeSystem 	= TypeSystem {	tsName :: Name, 	-- what is this typesystem's name?
					tsSyntax	:: BNFRules,	-- synax of the language
					tsFunctions 	:: Functions,	-- syntax functions of the TS 
					tsRelations	:: [Relation],
					tsRules 	:: Map Symbol [Rule]	-- predicates and inference rules of the type system, most often used for evaluation and/or typing rules; sorted by conclusion relation
					} deriving (Show)




---------------------------------------------------------------------------
------------------------------ UTILITIES ----------------------------------
---------------------------------------------------------------------------

instance Show Expression where
	show (MVar mt n)	= n
	show (MLiteral mt s)	= show s
	show (MIdentifier mt i)	= show i
	show (MInt mt i)	= show i
	show (MSeq mt exprs)	= exprs |> show & unwords & inParens 
	show (MCall mt nm builtin args)
				= let args'	= args & showComma & inParens
				  in (if builtin then "!" else "") ++ nm ++ args' ++ ": "++show mt
	show (MAscription nm expr)	= (show expr ++ ":" ++ nm) & inParens




showT (MVar mt n)	= n ++ showTI mt
showT (MLiteral mt s)	= show s ++ showTI mt
showT (MIdentifier mt i)= show i ++ showTI mt
showT (MInt mt i)	= show i ++ showTI mt
showT (MSeq mt exprs)	= exprs |> showT & unwords & inParens & (++ showTI mt)
showT (MCall mt nm builtin args)
			= let args'	= args |> showT & intercalate ", " & inParens
			  in (if builtin then "!" else "") ++ nm ++ args' ++ ": "++show mt
showT (MAscription nm expr)	= (showT expr ++ ":" ++ nm) & inParens

showTI ("", _)	= ""
showTI (mt, -1) = ": "++mt
showTI (mt, i)	= ": "++mt++"."++show i

show' (MVar mt n)	= show n
show' (MLiteral _ s)	= s
show' (MIdentifier _ s)	= s
show' (MInt _ i)	= show i
show' (MSeq mt exprs)	= exprs |> show' & unwords
show' (MCall mt nm builtin args)
			= let args'	= args & showComma & inParens
			  in (if builtin then "!" else "") ++ nm ++ args' ++ ": "++show mt
show' (MAscription _ expr)	= show' expr & inParens



instance Show Function where
	show (MFunction tp clauses)
		= let	sign	= ": "++show tp
			clss	= clauses |> show in
			(sign:clss) & intercalate "\n"


instance Show Clause where
	show (MClause patterns expr)
		= (patterns |> show' & intercalate ", ") ++ " = "++show' expr


instance Show Relation where
	show (Relation symbol tps pronounce)
		= let	sign	= inParens symbol ++ " : "++ (show tps)	:: String
			pron	= pronounce |> show |> ("\tPronounced as "++) & fromMaybe "" 	:: String in
			sign ++ pron

instance Show Conclusion where
	show (RelationMet rel [arg1, arg2])
			= show arg1 ++ " " ++ relSymbol rel ++ " " ++ show arg2
	show (RelationMet rel args)
			= inParens (relSymbol rel) ++ inParens (args |> show |> inParens & unwords)


instance Show Predicate	where
	show (TermIsA e typ)	= inParens (show e++": "++typ)
	show (Needed concl)	= show concl

instance Show Rule where
	show (Rule nm predicates conclusion)
		= let	predicates'	= predicates |> show & intercalate "\t"
			conclusion'	= show conclusion
			nm'	= inParens nm
			spacing	= replicate ( 1 + length nm') ' ' ++ "\t"
			line	= replicate (max (length predicates') (length conclusion')) '-'
			in
			["", spacing ++ predicates', nm' ++ "\t" ++ line, spacing ++ conclusion'] & unlines


instance Show Proof where
	show proof = showProof True proof & unlines
	


showProof	:: Bool -> Proof -> [String]
showProof _ (ProofIsA expr typ)	= [inParens (show expr ++ " : "++show typ)]
showProof showName (Proof concl proverRule predicates)
	= let	preds'	= predicates |> showProof showName
		preds''	= if null preds' then [] else init preds' ||>> (++"   ")  ++ [last preds']
		preds	= preds'' & foldl (stitch ' ') []	:: [String]
		predsW	= ("":preds) |> length & maximum	:: Int
		concl'	= show concl
		line	= replicate (max predsW (length concl')) '-'		:: String
		line'	= line ++ if showName then " " ++ inParens (ruleName proverRule) else ""
		in
		(preds ++ [line', concl'])

