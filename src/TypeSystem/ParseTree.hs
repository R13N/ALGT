 {-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE MultiParamTypeClasses #-}
module TypeSystem.ParseTree where

import Utils.Utils
import Utils.ToString
import Utils.ToStringExtra

import TypeSystem.Types

-- info about which BNF-rule was used constructing the ParseTree
type MInfo	= (TypeName, Int)

instance Refactorable TypeName MInfo where
	refactor ftn (tn, i)	= (ftn tn, i)

-- Represents values that can only come from target language
data ParseTree
	= MLiteral MInfo String			-- Generated by a literal expression
	| MIdentifier MInfo Name		-- identifier, generated by 'Identifier'
	| MInt MInfo Int			-- number, generated by 'Number'
	| PtSeq MInfo [ParseTree]		-- Sequence of stuff
	deriving (Show, Ord, Eq)

instance SimplyTyped ParseTree where
	typeOf pt	= typeInfoOf' pt & either id fst

typeInfoOf'		:: ParseTree -> Either TypeName (TypeName, Int)
typeInfoOf' (MLiteral tp _)		= Right tp
typeInfoOf' (MInt tp _) 		= Right tp
typeInfoOf' (MIdentifier tp _)		= Right tp
typeInfoOf' (PtSeq tp _)		= Right tp


replace	:: ParseTree -> Path -> ParseTree -> ParseTree
replace _ [] toPlace	= toPlace
replace (PtSeq tp orig) (i:rest) toPlace
 | length orig <= i
	= error $ "Invalid substitution path: index "++show i++" to big for " ++show orig
 | otherwise
	= let	(init, head:tail)	= splitAt i orig
		head'		= replace head rest toPlace in
		(init ++ (head':tail)) & PtSeq tp
replace rest path toReplace
	= error $ "Invalid substitution path: not a sequence, but trying to execute the path "++show path++" on " ++show rest

isMInt'	:: ParseTree -> Bool
isMInt' (MInt _ _)	= True
isMInt' _		= False

isPtSeq	:: ParseTree -> Bool
isPtSeq (PtSeq _ _)	= True
isPtSeq _		= False

usedIdentifiers'	:: ParseTree -> [Name]
usedIdentifiers' (MIdentifier _ nm)	= [nm]
usedIdentifiers' (PtSeq _ pts)		= pts >>= usedIdentifiers'


instance Refactorable TypeName ParseTree where
	refactor ftn (MLiteral mi s)	= MLiteral (refactor ftn mi) s
	refactor ftn (MIdentifier mi n)	= MIdentifier (refactor ftn mi) n
	refactor ftn (MInt mi i)	= MInt (refactor ftn mi) i
	refactor ftn (PtSeq mi seq)	= seq |> refactor ftn & PtSeq (refactor ftn mi)



instance ToString' ShowParens ParseTree where
	show'		= const show

	-- show as if this parsetree was an expression in the declaring file
	toParsable' _ (MLiteral _ s)	= s
	toParsable' _ (MIdentifier _ i)	= i
	toParsable' _ (MInt _ i)	= show i
	toParsable' p (PtSeq _ exprs)	= exprs |> toParsable' (deepen p) & unwords & inParens' p

	-- show as if this parsetree was an expression in the typesystem file
	toCoParsable' _ (MLiteral _ s)	= show s
	toCoParsable' _ (MIdentifier _ i)= show i
	toCoParsable' _ (MInt _ i)	= show i
	toCoParsable' p (PtSeq _ exprs)	= exprs |> toCoParsable' (deepen p) & unwords & inParens' p

	debug' _ (MLiteral ti s)	= show s ++ showTI ti
	debug' _ (MIdentifier ti i)	= show i ++ showTI ti
	debug' _ (MInt ti i)		= show i ++ showTI ti
	debug' p (PtSeq ti exprs)	= showTI ti ++ "\n" ++ (exprs |> debug' p & unlines & indent)

instance ToString ParseTree where
	toParsable	= toParsable' NotOnRoot
	toCoParsable	= toCoParsable' NotOnRoot
	debug		= debug' NotOnRoot		


