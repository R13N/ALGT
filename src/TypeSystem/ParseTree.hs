 {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, TemplateHaskell #-}
module TypeSystem.ParseTree where

import Utils.Utils
import Utils.ToString
import Utils.ToStringExtra

import TypeSystem.Types

import Lens.Micro hiding ((&))
import Lens.Micro.TH

-- info about which BNF-rule was used constructing the ParseTree
type MInfo	= (TypeName, Int)

instance Refactorable TypeName MInfo where
	refactor ftn (tn, i)	= (ftn tn, i)

-- Represents values that can only come from target language
data ParseTree
	= MLiteral 	{ _ptInf :: MInfo, _ptContents :: String}			-- Generated by a literal expression
	| MIdentifier 	{ _ptInf :: MInfo, _ptName :: Name}		-- identifier, generated by 'Identifier'
	| MInt	 	{ _ptInf :: MInfo, _ptInt :: Int}			-- number, generated by 'Number'
	| PtSeq 	{ _ptInf :: MInfo, _ptPts :: [ParseTree]}	-- Sequence of stuff
	deriving (Show, Ord, Eq)
makeLenses ''ParseTree

data LocationInfo = LocationInfo
	{ _liTokenStartLine	:: Int
	, _liTokenStartColumn	:: Int
	, _liTokenStopLine	:: Int
	, _liTokenLineColumn	:: Int
	} deriving (Show, Ord, Eq)
makeLenses ''LocationInfo

-- Annotated parse tree
data ParseTreeA a
	= MLiteralA 	{_ptAnnot :: a, _ptaInf :: MInfo, _ptaContents :: String}
	| MIdentifierA	{_ptAnnot :: a, _ptaInf :: MInfo, _ptaName :: Name}
	| MIntA		{_ptAnnot :: a, _ptaInf :: MInfo, _ptaInt :: Int}	
	| PtSeqA	{_ptAnnot :: a, _ptaInf :: MInfo, _ptaPts :: [ParseTreeA a]}	
makeLenses ''ParseTreeA

instance Functor ParseTreeA where
	fmap f (MLiteralA a minf str)	= MLiteralA (f a) minf str
	fmap f (MIdentifierA a minf n)	= MIdentifierA (f a) minf n
	fmap f (MIntA a minf i)		= MIntA (f a) minf i
	fmap f (PtSeqA a minf pts)	= pts |> fmap f & PtSeqA (f a) minf

type ParseTreeLi	= ParseTreeA LocationInfo

deAnnot	:: ParseTreeA a -> ParseTree
deAnnot (MLiteralA a minf str)	= MLiteral minf str
deAnnot (MIdentifierA a minf n)	= MIdentifier minf n
deAnnot (MIntA a minf i)	= MInt minf i
deAnnot (PtSeqA a minf pts)	= pts |> deAnnot & PtSeq minf

annot	:: a -> ParseTree -> ParseTreeA a
annot a (MLiteral minf str)	= MLiteralA a minf str
annot a (MIdentifier minf n)	= MIdentifierA a minf n
annot a (MInt minf i)		= MIntA a minf i
annot a (PtSeq minf pts)	= pts |> annot a & PtSeqA a minf 

flatten	:: ParseTreeA a -> (a, MInfo, String)
flatten (MLiteralA a minf str)	= (a, minf, str)
flatten (MIdentifierA a minf n)	= (a, minf, n)
flatten (MIntA a minf i)	= (a, minf, show i)
flatten (PtSeqA a minf pts)	= (a, minf, (pts |> flatten) >>= trd3)

	

instance SimplyTyped ParseTree where
	typeOf pt	= typeInfoOf' pt & either id fst

typeInfoOf'		:: ParseTree -> Either TypeName (TypeName, Int)
typeInfoOf' (MLiteral tp _)		= Right tp
typeInfoOf' (MInt tp _) 		= Right tp
typeInfoOf' (MIdentifier tp _)		= Right tp
typeInfoOf' (PtSeq tp _)		= Right tp


replace	:: ParseTree -> Path -> ParseTree -> ParseTree
replace _ [] toPlace	= toPlace
replace (PtSeq tp orig) (i:rest) toPlace
 | length orig <= i
	= error $ "Invalid substitution path: index "++show i++" to big for " ++show orig
 | otherwise
	= let	(init, head:tail)	= splitAt i orig
		head'		= replace head rest toPlace in
		(init ++ (head':tail)) & PtSeq tp
replace rest path toReplace
	= error $ "Invalid substitution path: not a sequence, but trying to execute the path "++show path++" on " ++show rest


search	:: (ParseTree -> Bool) -> ParseTree -> [Path]
search pred pt@(PtSeq _ pts)
 | pred pt	= [ [] ]
 | otherwise	= do	(i, pt') 	<- mapi pts
			path		<- search pred pt'
			return $ i:path
search pred pt
 | pred pt	= [ [] ]
 | otherwise	= []


isMInt'	:: ParseTree -> Bool
isMInt' (MInt _ _)	= True
isMInt' _		= False

isPtSeq	:: ParseTree -> Bool
isPtSeq (PtSeq _ _)	= True
isPtSeq _		= False

usedIdentifiers'	:: ParseTree -> [Name]
usedIdentifiers' (MIdentifier _ nm)	= [nm]
usedIdentifiers' (PtSeq _ pts)		= pts >>= usedIdentifiers'


instance Refactorable TypeName ParseTree where
	refactor ftn (MLiteral mi s)	= MLiteral (refactor ftn mi) s
	refactor ftn (MIdentifier mi n)	= MIdentifier (refactor ftn mi) n
	refactor ftn (MInt mi i)	= MInt (refactor ftn mi) i
	refactor ftn (PtSeq mi seq)	= seq |> refactor ftn & PtSeq (refactor ftn mi)



instance ToString' ShowParens ParseTree where
	show'		= const show

	-- show as if this parsetree was an expression in the declaring file
	toParsable' _ (MLiteral _ s)	= s
	toParsable' _ (MIdentifier _ i)	= i
	toParsable' _ (MInt _ i)	= show i
	toParsable' p (PtSeq _ exprs)	= exprs |> toParsable' (deepen p) & unwords & inParens' p

	-- show as if this parsetree was an expression in the typesystem file
	toCoParsable' _ (MLiteral _ s)	= show s
	toCoParsable' _ (MIdentifier _ i)= show i
	toCoParsable' _ (MInt _ i)	= show i
	toCoParsable' p (PtSeq _ exprs)	= exprs |> toCoParsable' (deepen p) & unwords & inParens' p

	debug' _ (MLiteral ti s)	= show s ++ showTI ti
	debug' _ (MIdentifier ti i)	= show i ++ showTI ti
	debug' _ (MInt ti i)		= show i ++ showTI ti
	debug' p (PtSeq ti exprs)	= "+ " ++ tail (showTI ti) ++ "\n" ++ (exprs |> debug' p & unlines & indentWith "|  ")

instance ToString ParseTree where
	toParsable	= toParsable' NotOnRoot
	toCoParsable	= toCoParsable' NotOnRoot
	debug		= debug' NotOnRoot		


