module Utils.STFL where

{-
This module defines the entire STFL.typesystem.
Used for integrationtests only! 
-}

import TypeSystem
import Data.Map

stfl = TypeSystem {tsName = "../Examples/STFL.typesystem"
	, tsSyntax = BNFRules {getBNF = fromList [("bool",[Literal "True",Literal "False"])
		,("e",[BNFSeq [BNFRuleCall "eL",Literal "+",BNFRuleCall "e"],BNFSeq [BNFRuleCall "eL",Literal "::",BNFRuleCall "type"],BNFSeq [BNFRuleCall "eL",BNFRuleCall "e"],BNFRuleCall "eL"])
		,("eL",[BNFRuleCall "number",BNFRuleCall "bool",BNFRuleCall "var",BNFSeq [Literal "(",Literal "\\",BNFRuleCall "var",Literal ":",BNFRuleCall "type",Literal ".",BNFRuleCall "e",Literal ")"],BNFSeq [Literal "If",BNFRuleCall "e",Literal "Then",BNFRuleCall "e",Literal "Else",BNFRuleCall "e"],BNFSeq [Literal "(",BNFRuleCall "e",Literal ")"]])
		,("number",[Number])
		,("type",[BNFSeq [BNFRuleCall "typeL",Literal "->",BNFRuleCall "type"],BNFRuleCall "typeL"])
		,("typeL",[Literal "Int",Literal "Bool",BNFSeq [Literal "(",BNFRuleCall "type",Literal ")"]])
		,("typing",[BNFSeq [BNFRuleCall "var",Literal ":",BNFRuleCall "type"]])
		,("typingEnvironment",[BNFSeq [BNFRuleCall "typing",Literal ",",BNFRuleCall "typingEnvironment"],Literal "{}"])
		,("var",[Identifier])]}
	, tsFunctions = fromList [("cod",MFunction ["type","type"] [MClause {mecPatterns = [MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MVar "type" "T",MParseTree (MLiteral ("typeL",2) ")")]], mecExpr = MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MCall "type" "cod" False [MVar "type" "T"],MParseTree (MLiteral ("typeL",2) ")")]},MClause {mecPatterns = [MSeq ("type",0) [MVar "typeL" "T1",MParseTree (MLiteral ("type",0) "->"),MVar "type" "T2"]], mecExpr = MVar "type" "T2"},MClause {mecPatterns = [MVar "type" "t0"], mecExpr = MCall "" "error" True [MParseTree (MLiteral ("",-1) "Undefined behaviour: non exhaustive patterns in function cod")]}])
		,("dom",MFunction ["type","type"] [MClause {mecPatterns = [MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MVar "type" "T",MParseTree (MLiteral ("typeL",2) ")")]], mecExpr = MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MCall "type" "dom" False [MVar "type" "T"],MParseTree (MLiteral ("typeL",2) ")")]},MClause {mecPatterns = [MSeq ("type",0) [MVar "typeL" "T1",MParseTree (MLiteral ("type",0) "->"),MVar "type" "T2"]], mecExpr = MVar "type" "T1"},MClause {mecPatterns = [MVar "type" "t0"], mecExpr = MCall "" "error" True [MParseTree (MLiteral ("",-1) "Undefined behaviour: non exhaustive patterns in function dom")]}])
		,("plus",MFunction ["number","e","e"] [MClause {mecPatterns = [MVar "number" "e1",MVar "e" "e2"], mecExpr = MCall "" "plus" True [MVar "number" "e1",MVar "" "e2"]},MClause {mecPatterns = [MVar "number" "t0",MVar "e" "t1"], mecExpr = MCall "" "error" True [MParseTree (MLiteral ("",-1) "Undefined behaviour: non exhaustive patterns in function plus")]}])
		,("rename",MFunction ["var","var","type","e","e"] [MClause {mecPatterns = [MVar "var" "x",MVar "var" "newVar",MVar "type" "type",MVar "e" "body"], mecExpr = MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "newVar",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "type",MParseTree (MLiteral ("eL",3) "."),MCall "e" "subs" False [MVar "var" "x",MVar "e" "newVar",MVar "e" "body"],MParseTree (MLiteral ("eL",3) ")")]},MClause {mecPatterns = [MVar "var" "t0",MVar "var" "t1",MVar "type" "t2",MVar "e" "t3"], mecExpr = MCall "" "error" True [MParseTree (MLiteral ("",-1) "Undefined behaviour: non exhaustive patterns in function rename")]}])
		,("subs",MFunction ["var","e","e","e"] [MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MVar "e" "x"], mecExpr = MVar "e" "y"},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "x",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "t",MParseTree (MLiteral ("eL",3) "."),MVar "e" "rest",MParseTree (MLiteral ("eL",3) ")")]], mecExpr = MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MCall "e" "rename" False [MVar "var" "x",MCall "" "newvar" True [MVar "" "x",MVar "" "rest"],MVar "type" "t",MVar "e" "rest"]]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "z",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "t",MParseTree (MLiteral ("eL",3) "."),MVar "e" "rest",MParseTree (MLiteral ("eL",3) ")")]], mecExpr = MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "z",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "t",MParseTree (MLiteral ("eL",3) "."),MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "rest"],MParseTree (MLiteral ("eL",3) ")")]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("eL",4) [MParseTree (MLiteral ("eL",4) "If"),MVar "e" "cond",MParseTree (MLiteral ("eL",4) "Then"),MVar "e" "e1",MParseTree (MLiteral ("eL",4) "Else"),MVar "e" "e2"]], mecExpr = MSeq ("eL",4) [MParseTree (MLiteral ("eL",4) "If"),MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "cond"],MParseTree (MLiteral ("eL",4) "Then"),MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "e1"],MParseTree (MLiteral ("eL",4) "Else"),MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "e2"]]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("e",0) [MVar "eL" "e1",MParseTree (MLiteral ("e",0) "+"),MVar "e" "e2"]], mecExpr = MSeq ("e",0) [MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "e1"],MParseTree (MLiteral ("e",0) "+"),MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "e2"]]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("e",1) [MVar "eL" "e",MParseTree (MLiteral ("e",1) "::"),MVar "type" "type"]], mecExpr = MSeq ("e",1) [MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "e"],MParseTree (MLiteral ("e",1) "::"),MVar "type" "type"]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MSeq ("e",2) [MVar "eL" "f",MVar "e" "arg"]], mecExpr = MSeq ("e",2) [MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "f"],MCall "e" "subs" False [MVar "var" "x",MVar "e" "y",MVar "e" "arg"]]},MClause {mecPatterns = [MVar "var" "x",MVar "e" "y",MVar "e" "z"], mecExpr = MVar "e" "z"},MClause {mecPatterns = [MVar "var" "t0",MVar "e" "t1",MVar "e" "t2"], mecExpr = MCall "" "error" True [MParseTree (MLiteral ("",-1) "Undefined behaviour: non exhaustive patterns in function subs")]}])]
	, tsRelations = [Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"},Relation {relSymbol = "\8594*", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "big step"},Relation {relSymbol = "\10003", relTypesModes = [("e",In)], relPronounce = Just "is canonical"},Relation {relSymbol = "\8866", relTypesModes = [("typIngEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"},Relation {relSymbol = "::", relTypesModes = [("e",In)
		,("type",Out)], relPronounce = Just "type in empty context"},Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}]
	, tsRules' = Rules (fromList [("::",[Rule {ruleName = "TEmptyCtx", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MParseTree (MLiteral ("typingEnvironment",1) "{}"),MVar "e" "e",MVar "type" "T"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "::", relTypesModes = [("e",In)
		,("type",Out)], relPronounce = Just "type in empty context"}, conclusionArgs = [MVar "e" "e",MVar "type" "T"]}}])
		,("==",[Rule {ruleName = "EqBase", rulePreds = [Same (MVar "type" "T1") (MVar "type" "T2")], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "T1",MVar "type" "T2"]}},Rule {ruleName = "EqParL", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "T1",MVar "type" "T2"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MVar "type" "T1",MParseTree (MLiteral ("typeL",2) ")")],MVar "type" "T2"]}},Rule {ruleName = "EqParR", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "T1",MVar "type" "T2"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "T1",MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MVar "type" "T2",MParseTree (MLiteral ("typeL",2) ")")]]}},Rule {ruleName = "EqArrow", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "Ta1",MVar "type" "Ta2"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "Tb1",MVar "type" "Tb2"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MSeq ("type",0) [MVar "typeL" "Ta1",MParseTree (MLiteral ("type",0) "->"),MVar "type" "Tb1"],MSeq ("type",0) [MVar "typeL" "Ta2",MParseTree (MLiteral ("type",0) "->"),MVar "type" "Tb2"]]}}])
		,("\8594",[Rule {ruleName = "EvalCtx", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MVar "e" "e0",MVar "e" "e1"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MEvalContext "e" "e" (MVar "e" "e0"),MEvalContext "e" "e" (MVar "e" "e1")]}},Rule {ruleName = "EvalPlus", rulePreds = [TermIsA (MVar "number" "n1") "number",TermIsA (MVar "number" "n2") "number"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("e",0) [MAscription "number" (MVar "number" "n1"),MParseTree (MLiteral ("e",0) "+"),MVar "e" "n2"],MCall "e" "plus" False [MVar "number" "n1",MVar "e" "n2"]]}},Rule {ruleName = "EvalAscrBool", rulePreds = [TermIsA (MVar "bool" "b") "bool"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("e",1) [MVar "eL" "b",MParseTree (MLiteral ("e",1) "::"),MParseTree (MLiteral ("typeL",1) "Bool")],MVar "e" "b"]}},Rule {ruleName = "EvalCastInt", rulePreds = [TermIsA (MVar "number" "i") "number"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("e",1) [MVar "eL" "i",MParseTree (MLiteral ("e",1) "::"),MParseTree (MLiteral ("typeL",0) "Int")],MVar "e" "i"]}},Rule {ruleName = "EvalParens", rulePreds = [], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("eL",5) [MParseTree (MLiteral ("eL",5) "("),MVar "e" "e",MParseTree (MLiteral ("eL",5) ")")],MVar "e" "e"]}},Rule {ruleName = "EvalIfTrue", rulePreds = [], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("eL",4) [MParseTree (MLiteral ("eL",4) "If"),MParseTree (MLiteral ("bool",0) "True"),MParseTree (MLiteral ("eL",4) "Then"),MVar "e" "e1",MParseTree (MLiteral ("eL",4) "Else"),MVar "e" "e2"],MVar "e" "e1"]}},Rule {ruleName = "EvalIfFalse", rulePreds = [], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("eL",4) [MParseTree (MLiteral ("eL",4) "If"),MParseTree (MLiteral ("bool",1) "False"),MParseTree (MLiteral ("eL",4) "Then"),MVar "e" "e1",MParseTree (MLiteral ("eL",4) "Else"),MVar "e" "e2"],MVar "e" "e2"]}},Rule {ruleName = "EvalLamApp", rulePreds = [], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MSeq ("e",2) [MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "var",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "type",MParseTree (MLiteral ("eL",3) "."),MVar "e" "e",MParseTree (MLiteral ("eL",3) ")")],MVar "e" "arg"],MCall "e" "subs" False [MVar "var" "var",MVar "e" "arg",MVar "e" "e"]]}}])
		,("\8594*",[Rule {ruleName = "BigStepCanon", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\10003", relTypesModes = [("e",In)], relPronounce = Just "is canonical"}, conclusionArgs = [MVar "e" "e"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594*", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "big step"}, conclusionArgs = [MVar "e" "e",MVar "e" "e"]}},Rule {ruleName = "BigStepRec", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MVar "e" "e0",MVar "e" "e1"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8594*", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "big step"}, conclusionArgs = [MVar "e" "e1",MVar "e" "e2"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594*", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "big step"}, conclusionArgs = [MVar "e" "e0",MVar "e" "e2"]}},Rule {ruleName = "BigStepBase", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8594", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "evaluation"}, conclusionArgs = [MVar "e" "e0",MVar "e" "e1"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\10003", relTypesModes = [("e",In)], relPronounce = Just "is canonical"}, conclusionArgs = [MVar "e" "e1"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8594*", relTypesModes = [("e",In)
		,("e",Out)], relPronounce = Just "big step"}, conclusionArgs = [MVar "e" "e0",MVar "e" "e1"]}}])
		,("\8866",[Rule {ruleName = "Tnumber", rulePreds = [TermIsA (MVar "number" "n") "number"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "n",MParseTree (MLiteral ("typeL",0) "Int")]}},Rule {ruleName = "Tbool", rulePreds = [TermIsA (MVar "bool" "b") "bool"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "b",MParseTree (MLiteral ("typeL",1) "Bool")]}},Rule {ruleName = "TParens", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e",MVar "type" "T"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("eL",5) [MParseTree (MLiteral ("eL",5) "("),MVar "e" "e",MParseTree (MLiteral ("eL",5) ")")],MVar "type" "T"]}},Rule {ruleName = "TAscr", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e",MVar "type" "T"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("e",1) [MVar "eL" "e",MParseTree (MLiteral ("e",1) "::"),MVar "type" "T"],MVar "type" "T"]}},Rule {ruleName = "Tx", rulePreds = [], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MEvalContext "typingEnvironment" "\915" (MSeq ("typing",0) [MVar "var" "x",MParseTree (MLiteral ("typing",0) ":"),MVar "type" "T"]),MVar "e" "x",MVar "type" "T"]}},Rule {ruleName = "TPlus", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "n1",MParseTree (MLiteral ("typeL",0) "Int")]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "n2",MParseTree (MLiteral ("typeL",0) "Int")]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("e",0) [MVar "eL" "n1",MParseTree (MLiteral ("e",0) "+"),MVar "e" "n2"],MParseTree (MLiteral ("typeL",0) "Int")]}},Rule {ruleName = "TIf", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "c",MParseTree (MLiteral ("typeL",1) "Bool")]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e1",MVar "type" "T"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e2",MVar "type" "T"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("eL",4) [MParseTree (MLiteral ("eL",4) "If"),MVar "e" "c",MParseTree (MLiteral ("eL",4) "Then"),MVar "e" "e1",MParseTree (MLiteral ("eL",4) "Else"),MVar "e" "e2"],MVar "type" "T"]}},Rule {ruleName = "TLambda", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MSeq ("typingEnvironment",0) [MSeq ("typing",0) [MVar "var" "x",MParseTree (MLiteral ("typing",0) ":"),MVar "type" "T1"],MParseTree (MLiteral ("typingEnvironment",0) ","),MVar "typingEnvironment" "\915"],MVar "e" "e",MVar "type" "T2"]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("eL",3) [MParseTree (MLiteral ("eL",3) "("),MParseTree (MLiteral ("eL",3) "\\"),MVar "var" "x",MParseTree (MLiteral ("eL",3) ":"),MVar "type" "T1",MParseTree (MLiteral ("eL",3) "."),MVar "e" "e",MParseTree (MLiteral ("eL",3) ")")],MSeq ("type",0) [MSeq ("typeL",2) [MParseTree (MLiteral ("typeL",2) "("),MVar "type" "T1",MParseTree (MLiteral ("typeL",2) ")")],MParseTree (MLiteral ("type",0) "->"),MVar "type" "T2"]]}},Rule {ruleName = "Tapp", rulePreds = [Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e1",MVar "type" "Tfunc"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MVar "e" "e2",MVar "type" "Targ"]}),Needed (RelationMet {conclusionRel = Relation {relSymbol = "==", relTypesModes = [("type",In)
		,("type",In)], relPronounce = Just "equals"}, conclusionArgs = [MVar "type" "Targ",MCall "type" "dom" False [MVar "type" "Tfunc"]]})], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\8866", relTypesModes = [("typingEnvironment",In)
		,("e",In)
		,("type",Out)], relPronounce = Just "context entails typing"}, conclusionArgs = [MVar "typingEnvironment" "\915",MSeq ("e",2) [MVar "eL" "e1",MVar "e" "e2"],MCall "type" "cod" False [MVar "type" "Tfunc"]]}}])
		,("\10003",[Rule {ruleName = "CanonBool", rulePreds = [TermIsA (MVar "bool" "b") "bool"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\10003", relTypesModes = [("e",In)], relPronounce = Just "is canonical"}, conclusionArgs = [MVar "e" "b"]}},Rule {ruleName = "CanonNumber", rulePreds = [TermIsA (MVar "number" "n") "number"], ruleConcl = RelationMet {conclusionRel = Relation {relSymbol = "\10003", relTypesModes = [("e",In)], relPronounce = Just "is canonical"}, conclusionArgs = [MVar "e" "n"]}}])])}

